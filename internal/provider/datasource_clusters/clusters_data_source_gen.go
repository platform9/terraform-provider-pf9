// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_clusters

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ClustersDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"clusters": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"addon_operator_image_tag": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) addon operator image tag for this cluster.",
							MarkdownDescription: "(optional) addon operator image tag for this cluster.",
						},
						"allow_workloads_on_master": schema.Int64Attribute{
							Computed:            true,
							Description:         "Field is set to 1 if the master nodes can run non-critical workloads",
							MarkdownDescription: "Field is set to 1 if the master nodes can run non-critical workloads",
						},
						"app_catalog_enabled": schema.Int64Attribute{
							Computed:            true,
							Description:         "DEPRECATED. Field doesn't lead to any action on the cluster now. Field is set to 1 if app catalog is enabled, 0 otherwise",
							MarkdownDescription: "DEPRECATED. Field doesn't lead to any action on the cluster now. Field is set to 1 if app catalog is enabled, 0 otherwise",
						},
						"authz_enabled": schema.Int64Attribute{
							Computed:            true,
							Description:         "Field is set to 1 if authz is enabled, 0 otherwise",
							MarkdownDescription: "Field is set to 1 if authz is enabled, 0 otherwise",
						},
						"calico_controller_cpu_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_CONTROLLER_CPU_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_CONTROLLER_CPU_LIMIT environment variable in Calico.",
						},
						"calico_controller_memory_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_CONTROLLER_MEMORY_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_CONTROLLER_MEMORY_LIMIT environment variable in Calico.",
						},
						"calico_ip_ip_mode": schema.StringAttribute{
							Computed:            true,
							Description:         "IP-IP encapsulation mode for Calico network. Choose: Always, Never, CrossSubnet",
							MarkdownDescription: "IP-IP encapsulation mode for Calico network. Choose: Always, Never, CrossSubnet",
						},
						"calico_nat_outgoing": schema.BoolAttribute{
							Computed:            true,
							Description:         "Field is set to true if Calico nodes need to NAT north-south egress traffic.",
							MarkdownDescription: "Field is set to true if Calico nodes need to NAT north-south egress traffic.",
						},
						"calico_node_cpu_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_NODE_CPU_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_NODE_CPU_LIMIT environment variable in Calico.",
						},
						"calico_node_memory_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_NODE_MEMORY_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_NODE_MEMORY_LIMIT environment variable in Calico.",
						},
						"calico_typha_cpu_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_TYPHA_CPU_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_TYPHA_CPU_LIMIT environment variable in Calico.",
						},
						"calico_typha_memory_limit": schema.StringAttribute{
							Computed:            true,
							Description:         "Corresponds to the CALICO_TYPHA_MEMORY_LIMIT environment variable in Calico.",
							MarkdownDescription: "Corresponds to the CALICO_TYPHA_MEMORY_LIMIT environment variable in Calico.",
						},
						"calico_v4block_size": schema.StringAttribute{
							Computed:            true,
							Description:         "Subnet size per node for the Calico network, in CIDR notation (e.g. 26)",
							MarkdownDescription: "Subnet size per node for the Calico network, in CIDR notation (e.g. 26)",
						},
						"can_upgrade": schema.BoolAttribute{
							Computed:            true,
							Description:         "Field is set to true if the cluster can be upgraded, false otherwise",
							MarkdownDescription: "Field is set to true if the cluster can be upgraded, false otherwise",
						},
						"cert_expiry_hrs": schema.Int64Attribute{
							Computed:            true,
							Description:         "(optional) Number of hours before user certificates in kubeconfig expires, should be greater than 0 if set. Default is 24hrs.",
							MarkdownDescription: "(optional) Number of hours before user certificates in kubeconfig expires, should be greater than 0 if set. Default is 24hrs.",
						},
						"cloud_properties": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"ami": schema.StringAttribute{
									Computed:            true,
									Description:         "AMI ID used to provision cluster nodes",
									MarkdownDescription: "AMI ID used to provision cluster nodes",
								},
								"azs": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Availability zone(s) the cluster is deployed in",
									MarkdownDescription: "Availability zone(s) the cluster is deployed in",
								},
								"custom_ami": schema.StringAttribute{
									Computed:            true,
									Description:         "The custom ami name which can be specified by a user",
									MarkdownDescription: "The custom ami name which can be specified by a user",
								},
								"domain_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Domain used for cluster FQDNs",
									MarkdownDescription: "Domain used for cluster FQDNs",
								},
								"http_proxy": schema.StringAttribute{
									Computed:            true,
									Description:         "The http proxy used for node communications. This parameter is required when internalElb is set to true and the private subnet selected does not route IP packets to the internet through a VPN",
									MarkdownDescription: "The http proxy used for node communications. This parameter is required when internalElb is set to true and the private subnet selected does not route IP packets to the internet through a VPN",
								},
								"internal_elb": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to true if load balancer is an internal load balancer or false for an Internet-facing load balancer. More information here: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-internal-load-balancers.html Setting this parameter to true requires that isPrivate is set to true. If the private subnet selected is not configured to route IP packets through a VPN, then an httpProxy is required for node communications to work",
									MarkdownDescription: "Set to true if load balancer is an internal load balancer or false for an Internet-facing load balancer. More information here: https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-internal-load-balancers.html Setting this parameter to true requires that isPrivate is set to true. If the private subnet selected is not configured to route IP packets through a VPN, then an httpProxy is required for node communications to work",
								},
								"is_private": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to true if nodes are deployed using public subnet, false otherwise, applicable also for manual deploy. This parameter is required if internalElb is set to true.",
									MarkdownDescription: "Set to true if nodes are deployed using public subnet, false otherwise, applicable also for manual deploy. This parameter is required if internalElb is set to true.",
								},
								"master_flavor": schema.StringAttribute{
									Computed:            true,
									Description:         "Node flavor used for master node",
									MarkdownDescription: "Node flavor used for master node",
								},
								"private_subnets": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "The private subnet ID to which the cluster is deployed. This parameter is optional if vpc (VPC ID) is set. This parameter is required if vpc (VPC ID) is set and isPrivate is set to true. This parameter is ignored if vpc (VPC ID) is not set",
									MarkdownDescription: "The private subnet ID to which the cluster is deployed. This parameter is optional if vpc (VPC ID) is set. This parameter is required if vpc (VPC ID) is set and isPrivate is set to true. This parameter is ignored if vpc (VPC ID) is not set",
								},
								"region": schema.StringAttribute{
									Computed:            true,
									Description:         "Cloud provider region in which the cluster was created",
									MarkdownDescription: "Cloud provider region in which the cluster was created",
								},
								"service_fqdn": schema.StringAttribute{
									Computed:            true,
									Description:         "FQDN used to reference cluster services",
									MarkdownDescription: "FQDN used to reference cluster services",
								},
								"ssh_key": schema.StringAttribute{
									Computed:            true,
									Description:         "Public SSH key associated with the cluster nodes",
									MarkdownDescription: "Public SSH key associated with the cluster nodes",
								},
								"subnets": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"use_pf9domain": schema.StringAttribute{
									Computed:            true,
									Description:         "Set to true if platform9.net domain is used, false otherwise",
									MarkdownDescription: "Set to true if platform9.net domain is used, false otherwise",
								},
								"vpc": schema.StringAttribute{
									Computed:            true,
									Description:         "If set, creates cluster using this VPC ID. Otherwise, the cluster is deployed on a new VPC. This parameter is required if internalElb is set to true",
									MarkdownDescription: "If set, creates cluster using this VPC ID. Otherwise, the cluster is deployed on a new VPC. This parameter is required if internalElb is set to true",
								},
								"worker_flavor": schema.StringAttribute{
									Computed:            true,
									Description:         "Node flavor used for worker node",
									MarkdownDescription: "Node flavor used for worker node",
								},
							},
							CustomType: CloudPropertiesType{
								ObjectType: types.ObjectType{
									AttrTypes: CloudPropertiesValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cloud_provider_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the cloud provider used to create this cluster",
							MarkdownDescription: "Name of the cloud provider used to create this cluster",
						},
						"cloud_provider_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Type of the cloud provider used to create this cluster",
							MarkdownDescription: "Type of the cloud provider used to create this cluster",
						},
						"cloud_provider_uuid": schema.StringAttribute{
							Computed:            true,
							Description:         "UUID of the cloud provider used to create this cluster",
							MarkdownDescription: "UUID of the cloud provider used to create this cluster",
						},
						"container_runtime": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) Container runtime for this cluster. Valid values: [docker, containerd]",
							MarkdownDescription: "(optional) Container runtime for this cluster. Valid values: [docker, containerd]",
						},
						"containers_cidr": schema.StringAttribute{
							Computed:            true,
							Description:         "CIDR used for container IP addresses",
							MarkdownDescription: "CIDR used for container IP addresses",
						},
						"cpu_manager_policy": schema.StringAttribute{
							Computed:            true,
							Description:         "options: none, static; default: none",
							MarkdownDescription: "options: none, static; default: none",
						},
						"docker_centos_package_repo_url": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of the centos repo to be used for docker installation",
							MarkdownDescription: "(optional) URL of the centos repo to be used for docker installation",
						},
						"docker_private_registry": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of private Docker registry to fetch Platform9 images from",
							MarkdownDescription: "(optional) URL of private Docker registry to fetch Platform9 images from",
						},
						"docker_root": schema.StringAttribute{
							Computed:            true,
							Description:         "Root directory for docker",
							MarkdownDescription: "Root directory for docker",
						},
						"docker_ubuntu_package_repo_url": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of the ubuntu repo to be used for docker installation",
							MarkdownDescription: "(optional) URL of the ubuntu repo to be used for docker installation",
						},
						"enable_etcd_encryption": schema.StringAttribute{
							Computed:            true,
							Description:         "States whether tls encryption is enabled on etcd, Default:false",
							MarkdownDescription: "States whether tls encryption is enabled on etcd, Default:false",
						},
						"enable_metallb": schema.BoolAttribute{
							Computed:            true,
							Description:         "1 if metallb enabled. Defaults to 0",
							MarkdownDescription: "1 if metallb enabled. Defaults to 0",
						},
						"enable_profile_agent": schema.BoolAttribute{
							Computed:            true,
							Description:         "(optional) If set to true platform9 profile engine agent will be deployed on the cluster. This agent is required to be able to use profiles.",
							MarkdownDescription: "(optional) If set to true platform9 profile engine agent will be deployed on the cluster. This agent is required to be able to use profiles.",
						},
						"etcd_backup": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"daily_backup_time": schema.StringAttribute{
									Computed:            true,
									Description:         "etcd backup Timestamp for daily backup, specified in format 'HH:MM' ",
									MarkdownDescription: "etcd backup Timestamp for daily backup, specified in format 'HH:MM' ",
								},
								"interval_in_hours": schema.Int64Attribute{
									Computed:            true,
									Description:         "etcd backup interval, specified in Hours",
									MarkdownDescription: "etcd backup interval, specified in Hours",
								},
								"interval_in_mins": schema.Int64Attribute{
									Computed:            true,
									Description:         "etcd backup interval, specified in minutes",
									MarkdownDescription: "etcd backup interval, specified in minutes",
								},
								"is_etcd_backup_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to true if etcd backup should be enabled, false otherwise",
									MarkdownDescription: "Set to true if etcd backup should be enabled, false otherwise",
								},
								"max_interval_backup_count": schema.Int64Attribute{
									Computed:            true,
									Description:         "max number of Backups retention for interval type backups",
									MarkdownDescription: "max number of Backups retention for interval type backups",
								},
								"max_timestamp_backup_count": schema.Int64Attribute{
									Computed:            true,
									Description:         "max number of Backups retention for Timestamp type backups",
									MarkdownDescription: "max number of Backups retention for Timestamp type backups",
								},
								"storage_properties": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"local_path": schema.StringAttribute{
											Computed:            true,
											Description:         "Path on the local filesystem where the etcd backup should be stored. For 'local' storage type only.",
											MarkdownDescription: "Path on the local filesystem where the etcd backup should be stored. For 'local' storage type only.",
										},
									},
									CustomType: StoragePropertiesType{
										ObjectType: types.ObjectType{
											AttrTypes: StoragePropertiesValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"storage_type": schema.StringAttribute{
									Computed:            true,
									Description:         "Storage type for the etcd backup. Only 'local' is current supported type. 'local' saves backup to the node's local disk",
									MarkdownDescription: "Storage type for the etcd backup. Only 'local' is current supported type. 'local' saves backup to the node's local disk",
								},
								"task_error_detail": schema.StringAttribute{
									Computed:            true,
									Description:         "Details of the error occurred of the taskStatus returned is 'error'",
									MarkdownDescription: "Details of the error occurred of the taskStatus returned is 'error'",
								},
								"task_status": schema.StringAttribute{
									Computed:            true,
									Description:         "Status indicating whether the backup cron job on the Kubernetes cluster was successfully setup. Can be 'success' or 'error'",
									MarkdownDescription: "Status indicating whether the backup cron job on the Kubernetes cluster was successfully setup. Can be 'success' or 'error'",
								},
							},
							CustomType: EtcdBackupType{
								ObjectType: types.ObjectType{
									AttrTypes: EtcdBackupValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"etcd_data_dir": schema.StringAttribute{
							Computed:            true,
							Description:         "Data directory for etcd. The field is applicable to master nodes only",
							MarkdownDescription: "Data directory for etcd. The field is applicable to master nodes only",
						},
						"external_dns_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Optional DNS name for API endpoint. This field is autogenerated when pf9 domain is used.",
							MarkdownDescription: "Optional DNS name for API endpoint. This field is autogenerated when pf9 domain is used.",
						},
						"flannel_iface_label": schema.StringAttribute{
							Computed:            true,
							Description:         "The interface used by flannel for interhost communication",
							MarkdownDescription: "The interface used by flannel for interhost communication",
						},
						"flannel_public_iface_label": schema.StringAttribute{
							Computed:            true,
							Description:         "The IP address used as the flannel public IP for the nodes in the cluster",
							MarkdownDescription: "The IP address used as the flannel public IP for the nodes in the cluster",
						},
						"gcr_private_registry": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of private GCR registry to fetch Platform9 images from",
							MarkdownDescription: "(optional) URL of private GCR registry to fetch Platform9 images from",
						},
						"is_kubernetes": schema.Int64Attribute{
							Computed:            true,
							Description:         "Field is set to 1 if the cluster is a Kubernetes cluster, 0 otherwise",
							MarkdownDescription: "Field is set to 1 if the cluster is a Kubernetes cluster, 0 otherwise",
						},
						"k8s_api_port": schema.StringAttribute{
							Computed:            true,
							Description:         "Port on which K8S API Server will listen, 443 by default",
							MarkdownDescription: "Port on which K8S API Server will listen, 443 by default",
						},
						"k8s_private_registry": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of private K8S registry to fetch Platform9 images from",
							MarkdownDescription: "(optional) URL of private K8S registry to fetch Platform9 images from",
						},
						"keystone_enabled": schema.Int64Attribute{
							Computed:            true,
							Description:         "Field is set to 1 if keystone is enabled, 0 otherwise",
							MarkdownDescription: "Field is set to 1 if keystone is enabled, 0 otherwise",
						},
						"last_ok": schema.StringAttribute{
							Computed:            true,
							Description:         "The timestamp when the cluster last reported an OK status",
							MarkdownDescription: "The timestamp when the cluster last reported an OK status",
						},
						"last_op": schema.StringAttribute{
							Computed:            true,
							Description:         "The last operation such as node attach or node detach that was performed on the cluster",
							MarkdownDescription: "The last operation such as node attach or node detach that was performed on the cluster",
						},
						"master_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "Ip of the master node, applicable only for cloud provider type 'openstack'",
							MarkdownDescription: "Ip of the master node, applicable only for cloud provider type 'openstack'",
						},
						"master_status": schema.StringAttribute{
							Computed:            true,
							Description:         "Status of the master nodes. 'healthy' means all masters are healthy. 'partially healthy' means quorum number of masters are healthy, but some are not. 'unhealthy' means quorum number of master are unhealthy",
							MarkdownDescription: "Status of the master nodes. 'healthy' means all masters are healthy. 'partially healthy' means quorum number of masters are healthy, but some are not. 'unhealthy' means quorum number of master are unhealthy",
						},
						"master_vip_iface": schema.StringAttribute{
							Computed:            true,
							Description:         "The interface that VIP attaches to if specified. Defaults to empty string",
							MarkdownDescription: "The interface that VIP attaches to if specified. Defaults to empty string",
						},
						"master_vip_ipv4": schema.StringAttribute{
							Computed:            true,
							Description:         "API server Virtual IP that provides failover if specified for the cluster. Defaults to empty string",
							MarkdownDescription: "API server Virtual IP that provides failover if specified for the cluster. Defaults to empty string",
						},
						"master_vip_vrouter_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Virtual router id choosen for the cluster. Range: 0-254. Emptry string if masterVipIpv4 not specified",
							MarkdownDescription: "Virtual router id choosen for the cluster. Range: 0-254. Emptry string if masterVipIpv4 not specified",
						},
						"metallb_cidr": schema.StringAttribute{
							Computed:            true,
							Description:         "Comma separated pools of IPs like A.B.C.D-E.F.G.H, I.J.K.L-M.N.O.P that metallb will manage if specified",
							MarkdownDescription: "Comma separated pools of IPs like A.B.C.D-E.F.G.H, I.J.K.L-M.N.O.P that metallb will manage if specified",
						},
						"mtu_size": schema.StringAttribute{
							Computed:            true,
							Description:         "MTU for container network interfaces. Optional and used for the Calico network backend",
							MarkdownDescription: "MTU for container network interfaces. Optional and used for the Calico network backend",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the cluster",
							MarkdownDescription: "Name of the cluster",
						},
						"network_plugin": schema.StringAttribute{
							Computed:            true,
							Description:         "Network backend to use for container networking. Defaults to flannel. Supported choices are flannel, calico, noop, weave",
							MarkdownDescription: "Network backend to use for container networking. Defaults to flannel. Supported choices are flannel, calico, noop, weave",
						},
						"node_pool_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the node pool used for the cluster",
							MarkdownDescription: "Name of the node pool used for the cluster",
						},
						"node_pool_uuid": schema.StringAttribute{
							Computed:            true,
							Description:         "UUID of the node pool used for the cluster",
							MarkdownDescription: "UUID of the node pool used for the cluster",
						},
						"num_masters": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of master nodes in the cluster",
							MarkdownDescription: "Number of master nodes in the cluster",
						},
						"num_workers": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of worker nodes in the cluster",
							MarkdownDescription: "Number of worker nodes in the cluster",
						},
						"privileged": schema.Int64Attribute{
							Computed:            true,
							Description:         "Field is set to 1 if cluster runs privileged containers, 0 otherwise",
							MarkdownDescription: "Field is set to 1 if cluster runs privileged containers, 0 otherwise",
						},
						"project_id": schema.StringAttribute{
							Computed:            true,
							Description:         "UUID of the Keystone project that this cluster is part of",
							MarkdownDescription: "UUID of the Keystone project that this cluster is part of",
						},
						"quay_private_registry": schema.StringAttribute{
							Computed:            true,
							Description:         "(optional) URL of private Quay registry to fetch Platform9 images from",
							MarkdownDescription: "(optional) URL of private Quay registry to fetch Platform9 images from",
						},
						"reserved_cpus": schema.StringAttribute{
							Computed:            true,
							Description:         "list of CPUs to be reserved for the system. Ex: 1-3,5",
							MarkdownDescription: "list of CPUs to be reserved for the system. Ex: 1-3,5",
						},
						"runtime_config": schema.StringAttribute{
							Computed: true,
						},
						"services_cidr": schema.StringAttribute{
							Computed:            true,
							Description:         "CIDR used for service IP addresses",
							MarkdownDescription: "CIDR used for service IP addresses",
						},
						"status": schema.StringAttribute{
							Computed:            true,
							Description:         "Status of the cluster",
							MarkdownDescription: "Status of the cluster",
						},
						"tags": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{},
							CustomType: TagsType{
								ObjectType: types.ObjectType{
									AttrTypes: TagsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "User defined key-value pairs represented as a JSON object",
							MarkdownDescription: "User defined key-value pairs represented as a JSON object",
						},
						"task_error": schema.StringAttribute{
							Computed:            true,
							Description:         "Error details if the last task on cluster did not succeed",
							MarkdownDescription: "Error details if the last task on cluster did not succeed",
						},
						"task_status": schema.StringAttribute{
							Computed:            true,
							Description:         "Status of the last task that run on the cluster.",
							MarkdownDescription: "Status of the last task that run on the cluster.",
						},
						"topology_manager_policy": schema.StringAttribute{
							Computed:            true,
							Description:         "options: none, best-effort, restricted, single-numa-node; default: none",
							MarkdownDescription: "options: none, best-effort, restricted, single-numa-node; default: none",
						},
						"use_hostname": schema.BoolAttribute{
							Computed:            true,
							Description:         "(optioanl) If set to true nodes will be registered in the cluster using hostname instead of IP address. This option is only applicable to IPv4 hosts. This option is ignored when deploying clusters on IPv6 enabled hosts and public clouds - AWS, Azure, etc.",
							MarkdownDescription: "(optioanl) If set to true nodes will be registered in the cluster using hostname instead of IP address. This option is only applicable to IPv4 hosts. This option is ignored when deploying clusters on IPv6 enabled hosts and public clouds - AWS, Azure, etc.",
						},
						"uuid": schema.StringAttribute{
							Computed:            true,
							Description:         "UUID of the cluster",
							MarkdownDescription: "UUID of the cluster",
						},
						"worker_status": schema.StringAttribute{
							Computed:            true,
							Description:         "Status of the worker nodes. 'healthy' means all workers are healthy. 'partially healthy' means more than 50% of the workers are healthy, rest are unhealthy. 'unhealthy' means more than 50% of the workers are unhealthy",
							MarkdownDescription: "Status of the worker nodes. 'healthy' means all workers are healthy. 'partially healthy' means more than 50% of the workers are healthy, rest are unhealthy. 'unhealthy' means more than 50% of the workers are unhealthy",
						},
					},
					CustomType: ClustersType{
						ObjectType: types.ObjectType{
							AttrTypes: ClustersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"project_id": schema.StringAttribute{
				Required:            true,
				Description:         "UUID of the project the cluster belongs to",
				MarkdownDescription: "UUID of the project the cluster belongs to",
			},
		},
	}
}

type ClustersModel struct {
	Clusters  types.Set    `tfsdk:"clusters"`
	ProjectId types.String `tfsdk:"project_id"`
}

var _ basetypes.ObjectTypable = ClustersType{}

type ClustersType struct {
	basetypes.ObjectType
}

func (t ClustersType) Equal(o attr.Type) bool {
	other, ok := o.(ClustersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClustersType) String() string {
	return "ClustersType"
}

func (t ClustersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addonOperatorImageTagAttribute, ok := attributes["addon_operator_image_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addon_operator_image_tag is missing from object`)

		return nil, diags
	}

	addonOperatorImageTagVal, ok := addonOperatorImageTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addon_operator_image_tag expected to be basetypes.StringValue, was: %T`, addonOperatorImageTagAttribute))
	}

	allowWorkloadsOnMasterAttribute, ok := attributes["allow_workloads_on_master"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_workloads_on_master is missing from object`)

		return nil, diags
	}

	allowWorkloadsOnMasterVal, ok := allowWorkloadsOnMasterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_workloads_on_master expected to be basetypes.Int64Value, was: %T`, allowWorkloadsOnMasterAttribute))
	}

	appCatalogEnabledAttribute, ok := attributes["app_catalog_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_catalog_enabled is missing from object`)

		return nil, diags
	}

	appCatalogEnabledVal, ok := appCatalogEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_catalog_enabled expected to be basetypes.Int64Value, was: %T`, appCatalogEnabledAttribute))
	}

	authzEnabledAttribute, ok := attributes["authz_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authz_enabled is missing from object`)

		return nil, diags
	}

	authzEnabledVal, ok := authzEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authz_enabled expected to be basetypes.Int64Value, was: %T`, authzEnabledAttribute))
	}

	calicoControllerCpuLimitAttribute, ok := attributes["calico_controller_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_controller_cpu_limit is missing from object`)

		return nil, diags
	}

	calicoControllerCpuLimitVal, ok := calicoControllerCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_controller_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoControllerCpuLimitAttribute))
	}

	calicoControllerMemoryLimitAttribute, ok := attributes["calico_controller_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_controller_memory_limit is missing from object`)

		return nil, diags
	}

	calicoControllerMemoryLimitVal, ok := calicoControllerMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_controller_memory_limit expected to be basetypes.StringValue, was: %T`, calicoControllerMemoryLimitAttribute))
	}

	calicoIpIpModeAttribute, ok := attributes["calico_ip_ip_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_ip_ip_mode is missing from object`)

		return nil, diags
	}

	calicoIpIpModeVal, ok := calicoIpIpModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_ip_ip_mode expected to be basetypes.StringValue, was: %T`, calicoIpIpModeAttribute))
	}

	calicoNatOutgoingAttribute, ok := attributes["calico_nat_outgoing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_nat_outgoing is missing from object`)

		return nil, diags
	}

	calicoNatOutgoingVal, ok := calicoNatOutgoingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_nat_outgoing expected to be basetypes.BoolValue, was: %T`, calicoNatOutgoingAttribute))
	}

	calicoNodeCpuLimitAttribute, ok := attributes["calico_node_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_node_cpu_limit is missing from object`)

		return nil, diags
	}

	calicoNodeCpuLimitVal, ok := calicoNodeCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_node_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoNodeCpuLimitAttribute))
	}

	calicoNodeMemoryLimitAttribute, ok := attributes["calico_node_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_node_memory_limit is missing from object`)

		return nil, diags
	}

	calicoNodeMemoryLimitVal, ok := calicoNodeMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_node_memory_limit expected to be basetypes.StringValue, was: %T`, calicoNodeMemoryLimitAttribute))
	}

	calicoTyphaCpuLimitAttribute, ok := attributes["calico_typha_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_typha_cpu_limit is missing from object`)

		return nil, diags
	}

	calicoTyphaCpuLimitVal, ok := calicoTyphaCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_typha_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoTyphaCpuLimitAttribute))
	}

	calicoTyphaMemoryLimitAttribute, ok := attributes["calico_typha_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_typha_memory_limit is missing from object`)

		return nil, diags
	}

	calicoTyphaMemoryLimitVal, ok := calicoTyphaMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_typha_memory_limit expected to be basetypes.StringValue, was: %T`, calicoTyphaMemoryLimitAttribute))
	}

	calicoV4blockSizeAttribute, ok := attributes["calico_v4block_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_v4block_size is missing from object`)

		return nil, diags
	}

	calicoV4blockSizeVal, ok := calicoV4blockSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_v4block_size expected to be basetypes.StringValue, was: %T`, calicoV4blockSizeAttribute))
	}

	canUpgradeAttribute, ok := attributes["can_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_upgrade is missing from object`)

		return nil, diags
	}

	canUpgradeVal, ok := canUpgradeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_upgrade expected to be basetypes.BoolValue, was: %T`, canUpgradeAttribute))
	}

	certExpiryHrsAttribute, ok := attributes["cert_expiry_hrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry_hrs is missing from object`)

		return nil, diags
	}

	certExpiryHrsVal, ok := certExpiryHrsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry_hrs expected to be basetypes.Int64Value, was: %T`, certExpiryHrsAttribute))
	}

	cloudPropertiesAttribute, ok := attributes["cloud_properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_properties is missing from object`)

		return nil, diags
	}

	cloudPropertiesVal, ok := cloudPropertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_properties expected to be basetypes.ObjectValue, was: %T`, cloudPropertiesAttribute))
	}

	cloudProviderNameAttribute, ok := attributes["cloud_provider_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_name is missing from object`)

		return nil, diags
	}

	cloudProviderNameVal, ok := cloudProviderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_name expected to be basetypes.StringValue, was: %T`, cloudProviderNameAttribute))
	}

	cloudProviderTypeAttribute, ok := attributes["cloud_provider_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_type is missing from object`)

		return nil, diags
	}

	cloudProviderTypeVal, ok := cloudProviderTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_type expected to be basetypes.StringValue, was: %T`, cloudProviderTypeAttribute))
	}

	cloudProviderUuidAttribute, ok := attributes["cloud_provider_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_uuid is missing from object`)

		return nil, diags
	}

	cloudProviderUuidVal, ok := cloudProviderUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_uuid expected to be basetypes.StringValue, was: %T`, cloudProviderUuidAttribute))
	}

	containerRuntimeAttribute, ok := attributes["container_runtime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_runtime is missing from object`)

		return nil, diags
	}

	containerRuntimeVal, ok := containerRuntimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_runtime expected to be basetypes.StringValue, was: %T`, containerRuntimeAttribute))
	}

	containersCidrAttribute, ok := attributes["containers_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`containers_cidr is missing from object`)

		return nil, diags
	}

	containersCidrVal, ok := containersCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`containers_cidr expected to be basetypes.StringValue, was: %T`, containersCidrAttribute))
	}

	cpuManagerPolicyAttribute, ok := attributes["cpu_manager_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_manager_policy is missing from object`)

		return nil, diags
	}

	cpuManagerPolicyVal, ok := cpuManagerPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_manager_policy expected to be basetypes.StringValue, was: %T`, cpuManagerPolicyAttribute))
	}

	dockerCentosPackageRepoUrlAttribute, ok := attributes["docker_centos_package_repo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_centos_package_repo_url is missing from object`)

		return nil, diags
	}

	dockerCentosPackageRepoUrlVal, ok := dockerCentosPackageRepoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_centos_package_repo_url expected to be basetypes.StringValue, was: %T`, dockerCentosPackageRepoUrlAttribute))
	}

	dockerPrivateRegistryAttribute, ok := attributes["docker_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_private_registry is missing from object`)

		return nil, diags
	}

	dockerPrivateRegistryVal, ok := dockerPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_private_registry expected to be basetypes.StringValue, was: %T`, dockerPrivateRegistryAttribute))
	}

	dockerRootAttribute, ok := attributes["docker_root"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_root is missing from object`)

		return nil, diags
	}

	dockerRootVal, ok := dockerRootAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_root expected to be basetypes.StringValue, was: %T`, dockerRootAttribute))
	}

	dockerUbuntuPackageRepoUrlAttribute, ok := attributes["docker_ubuntu_package_repo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_ubuntu_package_repo_url is missing from object`)

		return nil, diags
	}

	dockerUbuntuPackageRepoUrlVal, ok := dockerUbuntuPackageRepoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_ubuntu_package_repo_url expected to be basetypes.StringValue, was: %T`, dockerUbuntuPackageRepoUrlAttribute))
	}

	enableEtcdEncryptionAttribute, ok := attributes["enable_etcd_encryption"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_etcd_encryption is missing from object`)

		return nil, diags
	}

	enableEtcdEncryptionVal, ok := enableEtcdEncryptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_etcd_encryption expected to be basetypes.StringValue, was: %T`, enableEtcdEncryptionAttribute))
	}

	enableMetallbAttribute, ok := attributes["enable_metallb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_metallb is missing from object`)

		return nil, diags
	}

	enableMetallbVal, ok := enableMetallbAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_metallb expected to be basetypes.BoolValue, was: %T`, enableMetallbAttribute))
	}

	enableProfileAgentAttribute, ok := attributes["enable_profile_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_profile_agent is missing from object`)

		return nil, diags
	}

	enableProfileAgentVal, ok := enableProfileAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_profile_agent expected to be basetypes.BoolValue, was: %T`, enableProfileAgentAttribute))
	}

	etcdBackupAttribute, ok := attributes["etcd_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etcd_backup is missing from object`)

		return nil, diags
	}

	etcdBackupVal, ok := etcdBackupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etcd_backup expected to be basetypes.ObjectValue, was: %T`, etcdBackupAttribute))
	}

	etcdDataDirAttribute, ok := attributes["etcd_data_dir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etcd_data_dir is missing from object`)

		return nil, diags
	}

	etcdDataDirVal, ok := etcdDataDirAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etcd_data_dir expected to be basetypes.StringValue, was: %T`, etcdDataDirAttribute))
	}

	externalDnsNameAttribute, ok := attributes["external_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns_name is missing from object`)

		return nil, diags
	}

	externalDnsNameVal, ok := externalDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns_name expected to be basetypes.StringValue, was: %T`, externalDnsNameAttribute))
	}

	flannelIfaceLabelAttribute, ok := attributes["flannel_iface_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flannel_iface_label is missing from object`)

		return nil, diags
	}

	flannelIfaceLabelVal, ok := flannelIfaceLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flannel_iface_label expected to be basetypes.StringValue, was: %T`, flannelIfaceLabelAttribute))
	}

	flannelPublicIfaceLabelAttribute, ok := attributes["flannel_public_iface_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flannel_public_iface_label is missing from object`)

		return nil, diags
	}

	flannelPublicIfaceLabelVal, ok := flannelPublicIfaceLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flannel_public_iface_label expected to be basetypes.StringValue, was: %T`, flannelPublicIfaceLabelAttribute))
	}

	gcrPrivateRegistryAttribute, ok := attributes["gcr_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcr_private_registry is missing from object`)

		return nil, diags
	}

	gcrPrivateRegistryVal, ok := gcrPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcr_private_registry expected to be basetypes.StringValue, was: %T`, gcrPrivateRegistryAttribute))
	}

	isKubernetesAttribute, ok := attributes["is_kubernetes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_kubernetes is missing from object`)

		return nil, diags
	}

	isKubernetesVal, ok := isKubernetesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_kubernetes expected to be basetypes.Int64Value, was: %T`, isKubernetesAttribute))
	}

	k8sApiPortAttribute, ok := attributes["k8s_api_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`k8s_api_port is missing from object`)

		return nil, diags
	}

	k8sApiPortVal, ok := k8sApiPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`k8s_api_port expected to be basetypes.StringValue, was: %T`, k8sApiPortAttribute))
	}

	k8sPrivateRegistryAttribute, ok := attributes["k8s_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`k8s_private_registry is missing from object`)

		return nil, diags
	}

	k8sPrivateRegistryVal, ok := k8sPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`k8s_private_registry expected to be basetypes.StringValue, was: %T`, k8sPrivateRegistryAttribute))
	}

	keystoneEnabledAttribute, ok := attributes["keystone_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keystone_enabled is missing from object`)

		return nil, diags
	}

	keystoneEnabledVal, ok := keystoneEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keystone_enabled expected to be basetypes.Int64Value, was: %T`, keystoneEnabledAttribute))
	}

	lastOkAttribute, ok := attributes["last_ok"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_ok is missing from object`)

		return nil, diags
	}

	lastOkVal, ok := lastOkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_ok expected to be basetypes.StringValue, was: %T`, lastOkAttribute))
	}

	lastOpAttribute, ok := attributes["last_op"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_op is missing from object`)

		return nil, diags
	}

	lastOpVal, ok := lastOpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_op expected to be basetypes.StringValue, was: %T`, lastOpAttribute))
	}

	masterIpAttribute, ok := attributes["master_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_ip is missing from object`)

		return nil, diags
	}

	masterIpVal, ok := masterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_ip expected to be basetypes.StringValue, was: %T`, masterIpAttribute))
	}

	masterStatusAttribute, ok := attributes["master_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_status is missing from object`)

		return nil, diags
	}

	masterStatusVal, ok := masterStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_status expected to be basetypes.StringValue, was: %T`, masterStatusAttribute))
	}

	masterVipIfaceAttribute, ok := attributes["master_vip_iface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_iface is missing from object`)

		return nil, diags
	}

	masterVipIfaceVal, ok := masterVipIfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_iface expected to be basetypes.StringValue, was: %T`, masterVipIfaceAttribute))
	}

	masterVipIpv4Attribute, ok := attributes["master_vip_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_ipv4 is missing from object`)

		return nil, diags
	}

	masterVipIpv4Val, ok := masterVipIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_ipv4 expected to be basetypes.StringValue, was: %T`, masterVipIpv4Attribute))
	}

	masterVipVrouterIdAttribute, ok := attributes["master_vip_vrouter_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_vrouter_id is missing from object`)

		return nil, diags
	}

	masterVipVrouterIdVal, ok := masterVipVrouterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_vrouter_id expected to be basetypes.StringValue, was: %T`, masterVipVrouterIdAttribute))
	}

	metallbCidrAttribute, ok := attributes["metallb_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metallb_cidr is missing from object`)

		return nil, diags
	}

	metallbCidrVal, ok := metallbCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metallb_cidr expected to be basetypes.StringValue, was: %T`, metallbCidrAttribute))
	}

	mtuSizeAttribute, ok := attributes["mtu_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu_size is missing from object`)

		return nil, diags
	}

	mtuSizeVal, ok := mtuSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu_size expected to be basetypes.StringValue, was: %T`, mtuSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkPluginAttribute, ok := attributes["network_plugin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_plugin is missing from object`)

		return nil, diags
	}

	networkPluginVal, ok := networkPluginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_plugin expected to be basetypes.StringValue, was: %T`, networkPluginAttribute))
	}

	nodePoolNameAttribute, ok := attributes["node_pool_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pool_name is missing from object`)

		return nil, diags
	}

	nodePoolNameVal, ok := nodePoolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pool_name expected to be basetypes.StringValue, was: %T`, nodePoolNameAttribute))
	}

	nodePoolUuidAttribute, ok := attributes["node_pool_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pool_uuid is missing from object`)

		return nil, diags
	}

	nodePoolUuidVal, ok := nodePoolUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pool_uuid expected to be basetypes.StringValue, was: %T`, nodePoolUuidAttribute))
	}

	numMastersAttribute, ok := attributes["num_masters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_masters is missing from object`)

		return nil, diags
	}

	numMastersVal, ok := numMastersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_masters expected to be basetypes.Int64Value, was: %T`, numMastersAttribute))
	}

	numWorkersAttribute, ok := attributes["num_workers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_workers is missing from object`)

		return nil, diags
	}

	numWorkersVal, ok := numWorkersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_workers expected to be basetypes.Int64Value, was: %T`, numWorkersAttribute))
	}

	privilegedAttribute, ok := attributes["privileged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privileged is missing from object`)

		return nil, diags
	}

	privilegedVal, ok := privilegedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privileged expected to be basetypes.Int64Value, was: %T`, privilegedAttribute))
	}

	projectIdAttribute, ok := attributes["project_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_id is missing from object`)

		return nil, diags
	}

	projectIdVal, ok := projectIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_id expected to be basetypes.StringValue, was: %T`, projectIdAttribute))
	}

	quayPrivateRegistryAttribute, ok := attributes["quay_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quay_private_registry is missing from object`)

		return nil, diags
	}

	quayPrivateRegistryVal, ok := quayPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quay_private_registry expected to be basetypes.StringValue, was: %T`, quayPrivateRegistryAttribute))
	}

	reservedCpusAttribute, ok := attributes["reserved_cpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_cpus is missing from object`)

		return nil, diags
	}

	reservedCpusVal, ok := reservedCpusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_cpus expected to be basetypes.StringValue, was: %T`, reservedCpusAttribute))
	}

	runtimeConfigAttribute, ok := attributes["runtime_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`runtime_config is missing from object`)

		return nil, diags
	}

	runtimeConfigVal, ok := runtimeConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`runtime_config expected to be basetypes.StringValue, was: %T`, runtimeConfigAttribute))
	}

	servicesCidrAttribute, ok := attributes["services_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services_cidr is missing from object`)

		return nil, diags
	}

	servicesCidrVal, ok := servicesCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services_cidr expected to be basetypes.StringValue, was: %T`, servicesCidrAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	taskErrorAttribute, ok := attributes["task_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_error is missing from object`)

		return nil, diags
	}

	taskErrorVal, ok := taskErrorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_error expected to be basetypes.StringValue, was: %T`, taskErrorAttribute))
	}

	taskStatusAttribute, ok := attributes["task_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_status is missing from object`)

		return nil, diags
	}

	taskStatusVal, ok := taskStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_status expected to be basetypes.StringValue, was: %T`, taskStatusAttribute))
	}

	topologyManagerPolicyAttribute, ok := attributes["topology_manager_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topology_manager_policy is missing from object`)

		return nil, diags
	}

	topologyManagerPolicyVal, ok := topologyManagerPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topology_manager_policy expected to be basetypes.StringValue, was: %T`, topologyManagerPolicyAttribute))
	}

	useHostnameAttribute, ok := attributes["use_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_hostname is missing from object`)

		return nil, diags
	}

	useHostnameVal, ok := useHostnameAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_hostname expected to be basetypes.BoolValue, was: %T`, useHostnameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	workerStatusAttribute, ok := attributes["worker_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_status is missing from object`)

		return nil, diags
	}

	workerStatusVal, ok := workerStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_status expected to be basetypes.StringValue, was: %T`, workerStatusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClustersValue{
		AddonOperatorImageTag:       addonOperatorImageTagVal,
		AllowWorkloadsOnMaster:      allowWorkloadsOnMasterVal,
		AppCatalogEnabled:           appCatalogEnabledVal,
		AuthzEnabled:                authzEnabledVal,
		CalicoControllerCpuLimit:    calicoControllerCpuLimitVal,
		CalicoControllerMemoryLimit: calicoControllerMemoryLimitVal,
		CalicoIpIpMode:              calicoIpIpModeVal,
		CalicoNatOutgoing:           calicoNatOutgoingVal,
		CalicoNodeCpuLimit:          calicoNodeCpuLimitVal,
		CalicoNodeMemoryLimit:       calicoNodeMemoryLimitVal,
		CalicoTyphaCpuLimit:         calicoTyphaCpuLimitVal,
		CalicoTyphaMemoryLimit:      calicoTyphaMemoryLimitVal,
		CalicoV4blockSize:           calicoV4blockSizeVal,
		CanUpgrade:                  canUpgradeVal,
		CertExpiryHrs:               certExpiryHrsVal,
		CloudProperties:             cloudPropertiesVal,
		CloudProviderName:           cloudProviderNameVal,
		CloudProviderType:           cloudProviderTypeVal,
		CloudProviderUuid:           cloudProviderUuidVal,
		ContainerRuntime:            containerRuntimeVal,
		ContainersCidr:              containersCidrVal,
		CpuManagerPolicy:            cpuManagerPolicyVal,
		DockerCentosPackageRepoUrl:  dockerCentosPackageRepoUrlVal,
		DockerPrivateRegistry:       dockerPrivateRegistryVal,
		DockerRoot:                  dockerRootVal,
		DockerUbuntuPackageRepoUrl:  dockerUbuntuPackageRepoUrlVal,
		EnableEtcdEncryption:        enableEtcdEncryptionVal,
		EnableMetallb:               enableMetallbVal,
		EnableProfileAgent:          enableProfileAgentVal,
		EtcdBackup:                  etcdBackupVal,
		EtcdDataDir:                 etcdDataDirVal,
		ExternalDnsName:             externalDnsNameVal,
		FlannelIfaceLabel:           flannelIfaceLabelVal,
		FlannelPublicIfaceLabel:     flannelPublicIfaceLabelVal,
		GcrPrivateRegistry:          gcrPrivateRegistryVal,
		IsKubernetes:                isKubernetesVal,
		K8sApiPort:                  k8sApiPortVal,
		K8sPrivateRegistry:          k8sPrivateRegistryVal,
		KeystoneEnabled:             keystoneEnabledVal,
		LastOk:                      lastOkVal,
		LastOp:                      lastOpVal,
		MasterIp:                    masterIpVal,
		MasterStatus:                masterStatusVal,
		MasterVipIface:              masterVipIfaceVal,
		MasterVipIpv4:               masterVipIpv4Val,
		MasterVipVrouterId:          masterVipVrouterIdVal,
		MetallbCidr:                 metallbCidrVal,
		MtuSize:                     mtuSizeVal,
		Name:                        nameVal,
		NetworkPlugin:               networkPluginVal,
		NodePoolName:                nodePoolNameVal,
		NodePoolUuid:                nodePoolUuidVal,
		NumMasters:                  numMastersVal,
		NumWorkers:                  numWorkersVal,
		Privileged:                  privilegedVal,
		ProjectId:                   projectIdVal,
		QuayPrivateRegistry:         quayPrivateRegistryVal,
		ReservedCpus:                reservedCpusVal,
		RuntimeConfig:               runtimeConfigVal,
		ServicesCidr:                servicesCidrVal,
		Status:                      statusVal,
		Tags:                        tagsVal,
		TaskError:                   taskErrorVal,
		TaskStatus:                  taskStatusVal,
		TopologyManagerPolicy:       topologyManagerPolicyVal,
		UseHostname:                 useHostnameVal,
		Uuid:                        uuidVal,
		WorkerStatus:                workerStatusVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewClustersValueNull() ClustersValue {
	return ClustersValue{
		state: attr.ValueStateNull,
	}
}

func NewClustersValueUnknown() ClustersValue {
	return ClustersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClustersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClustersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClustersValue Attribute Value",
				"While creating a ClustersValue value, a missing attribute value was detected. "+
					"A ClustersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClustersValue Attribute Type",
				"While creating a ClustersValue value, an invalid attribute value was detected. "+
					"A ClustersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClustersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClustersValue Attribute Value",
				"While creating a ClustersValue value, an extra attribute value was detected. "+
					"A ClustersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClustersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClustersValueUnknown(), diags
	}

	addonOperatorImageTagAttribute, ok := attributes["addon_operator_image_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addon_operator_image_tag is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	addonOperatorImageTagVal, ok := addonOperatorImageTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addon_operator_image_tag expected to be basetypes.StringValue, was: %T`, addonOperatorImageTagAttribute))
	}

	allowWorkloadsOnMasterAttribute, ok := attributes["allow_workloads_on_master"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_workloads_on_master is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	allowWorkloadsOnMasterVal, ok := allowWorkloadsOnMasterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_workloads_on_master expected to be basetypes.Int64Value, was: %T`, allowWorkloadsOnMasterAttribute))
	}

	appCatalogEnabledAttribute, ok := attributes["app_catalog_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_catalog_enabled is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	appCatalogEnabledVal, ok := appCatalogEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_catalog_enabled expected to be basetypes.Int64Value, was: %T`, appCatalogEnabledAttribute))
	}

	authzEnabledAttribute, ok := attributes["authz_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authz_enabled is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	authzEnabledVal, ok := authzEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authz_enabled expected to be basetypes.Int64Value, was: %T`, authzEnabledAttribute))
	}

	calicoControllerCpuLimitAttribute, ok := attributes["calico_controller_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_controller_cpu_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoControllerCpuLimitVal, ok := calicoControllerCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_controller_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoControllerCpuLimitAttribute))
	}

	calicoControllerMemoryLimitAttribute, ok := attributes["calico_controller_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_controller_memory_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoControllerMemoryLimitVal, ok := calicoControllerMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_controller_memory_limit expected to be basetypes.StringValue, was: %T`, calicoControllerMemoryLimitAttribute))
	}

	calicoIpIpModeAttribute, ok := attributes["calico_ip_ip_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_ip_ip_mode is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoIpIpModeVal, ok := calicoIpIpModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_ip_ip_mode expected to be basetypes.StringValue, was: %T`, calicoIpIpModeAttribute))
	}

	calicoNatOutgoingAttribute, ok := attributes["calico_nat_outgoing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_nat_outgoing is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoNatOutgoingVal, ok := calicoNatOutgoingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_nat_outgoing expected to be basetypes.BoolValue, was: %T`, calicoNatOutgoingAttribute))
	}

	calicoNodeCpuLimitAttribute, ok := attributes["calico_node_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_node_cpu_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoNodeCpuLimitVal, ok := calicoNodeCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_node_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoNodeCpuLimitAttribute))
	}

	calicoNodeMemoryLimitAttribute, ok := attributes["calico_node_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_node_memory_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoNodeMemoryLimitVal, ok := calicoNodeMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_node_memory_limit expected to be basetypes.StringValue, was: %T`, calicoNodeMemoryLimitAttribute))
	}

	calicoTyphaCpuLimitAttribute, ok := attributes["calico_typha_cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_typha_cpu_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoTyphaCpuLimitVal, ok := calicoTyphaCpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_typha_cpu_limit expected to be basetypes.StringValue, was: %T`, calicoTyphaCpuLimitAttribute))
	}

	calicoTyphaMemoryLimitAttribute, ok := attributes["calico_typha_memory_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_typha_memory_limit is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoTyphaMemoryLimitVal, ok := calicoTyphaMemoryLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_typha_memory_limit expected to be basetypes.StringValue, was: %T`, calicoTyphaMemoryLimitAttribute))
	}

	calicoV4blockSizeAttribute, ok := attributes["calico_v4block_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`calico_v4block_size is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	calicoV4blockSizeVal, ok := calicoV4blockSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`calico_v4block_size expected to be basetypes.StringValue, was: %T`, calicoV4blockSizeAttribute))
	}

	canUpgradeAttribute, ok := attributes["can_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_upgrade is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	canUpgradeVal, ok := canUpgradeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_upgrade expected to be basetypes.BoolValue, was: %T`, canUpgradeAttribute))
	}

	certExpiryHrsAttribute, ok := attributes["cert_expiry_hrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry_hrs is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	certExpiryHrsVal, ok := certExpiryHrsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry_hrs expected to be basetypes.Int64Value, was: %T`, certExpiryHrsAttribute))
	}

	cloudPropertiesAttribute, ok := attributes["cloud_properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_properties is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	cloudPropertiesVal, ok := cloudPropertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_properties expected to be basetypes.ObjectValue, was: %T`, cloudPropertiesAttribute))
	}

	cloudProviderNameAttribute, ok := attributes["cloud_provider_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_name is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	cloudProviderNameVal, ok := cloudProviderNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_name expected to be basetypes.StringValue, was: %T`, cloudProviderNameAttribute))
	}

	cloudProviderTypeAttribute, ok := attributes["cloud_provider_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_type is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	cloudProviderTypeVal, ok := cloudProviderTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_type expected to be basetypes.StringValue, was: %T`, cloudProviderTypeAttribute))
	}

	cloudProviderUuidAttribute, ok := attributes["cloud_provider_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider_uuid is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	cloudProviderUuidVal, ok := cloudProviderUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider_uuid expected to be basetypes.StringValue, was: %T`, cloudProviderUuidAttribute))
	}

	containerRuntimeAttribute, ok := attributes["container_runtime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_runtime is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	containerRuntimeVal, ok := containerRuntimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_runtime expected to be basetypes.StringValue, was: %T`, containerRuntimeAttribute))
	}

	containersCidrAttribute, ok := attributes["containers_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`containers_cidr is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	containersCidrVal, ok := containersCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`containers_cidr expected to be basetypes.StringValue, was: %T`, containersCidrAttribute))
	}

	cpuManagerPolicyAttribute, ok := attributes["cpu_manager_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_manager_policy is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	cpuManagerPolicyVal, ok := cpuManagerPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_manager_policy expected to be basetypes.StringValue, was: %T`, cpuManagerPolicyAttribute))
	}

	dockerCentosPackageRepoUrlAttribute, ok := attributes["docker_centos_package_repo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_centos_package_repo_url is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	dockerCentosPackageRepoUrlVal, ok := dockerCentosPackageRepoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_centos_package_repo_url expected to be basetypes.StringValue, was: %T`, dockerCentosPackageRepoUrlAttribute))
	}

	dockerPrivateRegistryAttribute, ok := attributes["docker_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_private_registry is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	dockerPrivateRegistryVal, ok := dockerPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_private_registry expected to be basetypes.StringValue, was: %T`, dockerPrivateRegistryAttribute))
	}

	dockerRootAttribute, ok := attributes["docker_root"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_root is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	dockerRootVal, ok := dockerRootAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_root expected to be basetypes.StringValue, was: %T`, dockerRootAttribute))
	}

	dockerUbuntuPackageRepoUrlAttribute, ok := attributes["docker_ubuntu_package_repo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_ubuntu_package_repo_url is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	dockerUbuntuPackageRepoUrlVal, ok := dockerUbuntuPackageRepoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_ubuntu_package_repo_url expected to be basetypes.StringValue, was: %T`, dockerUbuntuPackageRepoUrlAttribute))
	}

	enableEtcdEncryptionAttribute, ok := attributes["enable_etcd_encryption"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_etcd_encryption is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	enableEtcdEncryptionVal, ok := enableEtcdEncryptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_etcd_encryption expected to be basetypes.StringValue, was: %T`, enableEtcdEncryptionAttribute))
	}

	enableMetallbAttribute, ok := attributes["enable_metallb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_metallb is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	enableMetallbVal, ok := enableMetallbAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_metallb expected to be basetypes.BoolValue, was: %T`, enableMetallbAttribute))
	}

	enableProfileAgentAttribute, ok := attributes["enable_profile_agent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_profile_agent is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	enableProfileAgentVal, ok := enableProfileAgentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_profile_agent expected to be basetypes.BoolValue, was: %T`, enableProfileAgentAttribute))
	}

	etcdBackupAttribute, ok := attributes["etcd_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etcd_backup is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	etcdBackupVal, ok := etcdBackupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etcd_backup expected to be basetypes.ObjectValue, was: %T`, etcdBackupAttribute))
	}

	etcdDataDirAttribute, ok := attributes["etcd_data_dir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`etcd_data_dir is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	etcdDataDirVal, ok := etcdDataDirAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`etcd_data_dir expected to be basetypes.StringValue, was: %T`, etcdDataDirAttribute))
	}

	externalDnsNameAttribute, ok := attributes["external_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns_name is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	externalDnsNameVal, ok := externalDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns_name expected to be basetypes.StringValue, was: %T`, externalDnsNameAttribute))
	}

	flannelIfaceLabelAttribute, ok := attributes["flannel_iface_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flannel_iface_label is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	flannelIfaceLabelVal, ok := flannelIfaceLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flannel_iface_label expected to be basetypes.StringValue, was: %T`, flannelIfaceLabelAttribute))
	}

	flannelPublicIfaceLabelAttribute, ok := attributes["flannel_public_iface_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flannel_public_iface_label is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	flannelPublicIfaceLabelVal, ok := flannelPublicIfaceLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flannel_public_iface_label expected to be basetypes.StringValue, was: %T`, flannelPublicIfaceLabelAttribute))
	}

	gcrPrivateRegistryAttribute, ok := attributes["gcr_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gcr_private_registry is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	gcrPrivateRegistryVal, ok := gcrPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gcr_private_registry expected to be basetypes.StringValue, was: %T`, gcrPrivateRegistryAttribute))
	}

	isKubernetesAttribute, ok := attributes["is_kubernetes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_kubernetes is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	isKubernetesVal, ok := isKubernetesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_kubernetes expected to be basetypes.Int64Value, was: %T`, isKubernetesAttribute))
	}

	k8sApiPortAttribute, ok := attributes["k8s_api_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`k8s_api_port is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	k8sApiPortVal, ok := k8sApiPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`k8s_api_port expected to be basetypes.StringValue, was: %T`, k8sApiPortAttribute))
	}

	k8sPrivateRegistryAttribute, ok := attributes["k8s_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`k8s_private_registry is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	k8sPrivateRegistryVal, ok := k8sPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`k8s_private_registry expected to be basetypes.StringValue, was: %T`, k8sPrivateRegistryAttribute))
	}

	keystoneEnabledAttribute, ok := attributes["keystone_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keystone_enabled is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	keystoneEnabledVal, ok := keystoneEnabledAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keystone_enabled expected to be basetypes.Int64Value, was: %T`, keystoneEnabledAttribute))
	}

	lastOkAttribute, ok := attributes["last_ok"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_ok is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	lastOkVal, ok := lastOkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_ok expected to be basetypes.StringValue, was: %T`, lastOkAttribute))
	}

	lastOpAttribute, ok := attributes["last_op"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_op is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	lastOpVal, ok := lastOpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_op expected to be basetypes.StringValue, was: %T`, lastOpAttribute))
	}

	masterIpAttribute, ok := attributes["master_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_ip is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	masterIpVal, ok := masterIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_ip expected to be basetypes.StringValue, was: %T`, masterIpAttribute))
	}

	masterStatusAttribute, ok := attributes["master_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_status is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	masterStatusVal, ok := masterStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_status expected to be basetypes.StringValue, was: %T`, masterStatusAttribute))
	}

	masterVipIfaceAttribute, ok := attributes["master_vip_iface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_iface is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	masterVipIfaceVal, ok := masterVipIfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_iface expected to be basetypes.StringValue, was: %T`, masterVipIfaceAttribute))
	}

	masterVipIpv4Attribute, ok := attributes["master_vip_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_ipv4 is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	masterVipIpv4Val, ok := masterVipIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_ipv4 expected to be basetypes.StringValue, was: %T`, masterVipIpv4Attribute))
	}

	masterVipVrouterIdAttribute, ok := attributes["master_vip_vrouter_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_vip_vrouter_id is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	masterVipVrouterIdVal, ok := masterVipVrouterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_vip_vrouter_id expected to be basetypes.StringValue, was: %T`, masterVipVrouterIdAttribute))
	}

	metallbCidrAttribute, ok := attributes["metallb_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metallb_cidr is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	metallbCidrVal, ok := metallbCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metallb_cidr expected to be basetypes.StringValue, was: %T`, metallbCidrAttribute))
	}

	mtuSizeAttribute, ok := attributes["mtu_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu_size is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	mtuSizeVal, ok := mtuSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu_size expected to be basetypes.StringValue, was: %T`, mtuSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkPluginAttribute, ok := attributes["network_plugin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_plugin is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	networkPluginVal, ok := networkPluginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_plugin expected to be basetypes.StringValue, was: %T`, networkPluginAttribute))
	}

	nodePoolNameAttribute, ok := attributes["node_pool_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pool_name is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	nodePoolNameVal, ok := nodePoolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pool_name expected to be basetypes.StringValue, was: %T`, nodePoolNameAttribute))
	}

	nodePoolUuidAttribute, ok := attributes["node_pool_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pool_uuid is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	nodePoolUuidVal, ok := nodePoolUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pool_uuid expected to be basetypes.StringValue, was: %T`, nodePoolUuidAttribute))
	}

	numMastersAttribute, ok := attributes["num_masters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_masters is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	numMastersVal, ok := numMastersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_masters expected to be basetypes.Int64Value, was: %T`, numMastersAttribute))
	}

	numWorkersAttribute, ok := attributes["num_workers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_workers is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	numWorkersVal, ok := numWorkersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_workers expected to be basetypes.Int64Value, was: %T`, numWorkersAttribute))
	}

	privilegedAttribute, ok := attributes["privileged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privileged is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	privilegedVal, ok := privilegedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privileged expected to be basetypes.Int64Value, was: %T`, privilegedAttribute))
	}

	projectIdAttribute, ok := attributes["project_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_id is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	projectIdVal, ok := projectIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_id expected to be basetypes.StringValue, was: %T`, projectIdAttribute))
	}

	quayPrivateRegistryAttribute, ok := attributes["quay_private_registry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quay_private_registry is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	quayPrivateRegistryVal, ok := quayPrivateRegistryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quay_private_registry expected to be basetypes.StringValue, was: %T`, quayPrivateRegistryAttribute))
	}

	reservedCpusAttribute, ok := attributes["reserved_cpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved_cpus is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	reservedCpusVal, ok := reservedCpusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved_cpus expected to be basetypes.StringValue, was: %T`, reservedCpusAttribute))
	}

	runtimeConfigAttribute, ok := attributes["runtime_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`runtime_config is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	runtimeConfigVal, ok := runtimeConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`runtime_config expected to be basetypes.StringValue, was: %T`, runtimeConfigAttribute))
	}

	servicesCidrAttribute, ok := attributes["services_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services_cidr is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	servicesCidrVal, ok := servicesCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services_cidr expected to be basetypes.StringValue, was: %T`, servicesCidrAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	taskErrorAttribute, ok := attributes["task_error"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_error is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	taskErrorVal, ok := taskErrorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_error expected to be basetypes.StringValue, was: %T`, taskErrorAttribute))
	}

	taskStatusAttribute, ok := attributes["task_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_status is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	taskStatusVal, ok := taskStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_status expected to be basetypes.StringValue, was: %T`, taskStatusAttribute))
	}

	topologyManagerPolicyAttribute, ok := attributes["topology_manager_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`topology_manager_policy is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	topologyManagerPolicyVal, ok := topologyManagerPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`topology_manager_policy expected to be basetypes.StringValue, was: %T`, topologyManagerPolicyAttribute))
	}

	useHostnameAttribute, ok := attributes["use_hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_hostname is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	useHostnameVal, ok := useHostnameAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_hostname expected to be basetypes.BoolValue, was: %T`, useHostnameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	workerStatusAttribute, ok := attributes["worker_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_status is missing from object`)

		return NewClustersValueUnknown(), diags
	}

	workerStatusVal, ok := workerStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_status expected to be basetypes.StringValue, was: %T`, workerStatusAttribute))
	}

	if diags.HasError() {
		return NewClustersValueUnknown(), diags
	}

	return ClustersValue{
		AddonOperatorImageTag:       addonOperatorImageTagVal,
		AllowWorkloadsOnMaster:      allowWorkloadsOnMasterVal,
		AppCatalogEnabled:           appCatalogEnabledVal,
		AuthzEnabled:                authzEnabledVal,
		CalicoControllerCpuLimit:    calicoControllerCpuLimitVal,
		CalicoControllerMemoryLimit: calicoControllerMemoryLimitVal,
		CalicoIpIpMode:              calicoIpIpModeVal,
		CalicoNatOutgoing:           calicoNatOutgoingVal,
		CalicoNodeCpuLimit:          calicoNodeCpuLimitVal,
		CalicoNodeMemoryLimit:       calicoNodeMemoryLimitVal,
		CalicoTyphaCpuLimit:         calicoTyphaCpuLimitVal,
		CalicoTyphaMemoryLimit:      calicoTyphaMemoryLimitVal,
		CalicoV4blockSize:           calicoV4blockSizeVal,
		CanUpgrade:                  canUpgradeVal,
		CertExpiryHrs:               certExpiryHrsVal,
		CloudProperties:             cloudPropertiesVal,
		CloudProviderName:           cloudProviderNameVal,
		CloudProviderType:           cloudProviderTypeVal,
		CloudProviderUuid:           cloudProviderUuidVal,
		ContainerRuntime:            containerRuntimeVal,
		ContainersCidr:              containersCidrVal,
		CpuManagerPolicy:            cpuManagerPolicyVal,
		DockerCentosPackageRepoUrl:  dockerCentosPackageRepoUrlVal,
		DockerPrivateRegistry:       dockerPrivateRegistryVal,
		DockerRoot:                  dockerRootVal,
		DockerUbuntuPackageRepoUrl:  dockerUbuntuPackageRepoUrlVal,
		EnableEtcdEncryption:        enableEtcdEncryptionVal,
		EnableMetallb:               enableMetallbVal,
		EnableProfileAgent:          enableProfileAgentVal,
		EtcdBackup:                  etcdBackupVal,
		EtcdDataDir:                 etcdDataDirVal,
		ExternalDnsName:             externalDnsNameVal,
		FlannelIfaceLabel:           flannelIfaceLabelVal,
		FlannelPublicIfaceLabel:     flannelPublicIfaceLabelVal,
		GcrPrivateRegistry:          gcrPrivateRegistryVal,
		IsKubernetes:                isKubernetesVal,
		K8sApiPort:                  k8sApiPortVal,
		K8sPrivateRegistry:          k8sPrivateRegistryVal,
		KeystoneEnabled:             keystoneEnabledVal,
		LastOk:                      lastOkVal,
		LastOp:                      lastOpVal,
		MasterIp:                    masterIpVal,
		MasterStatus:                masterStatusVal,
		MasterVipIface:              masterVipIfaceVal,
		MasterVipIpv4:               masterVipIpv4Val,
		MasterVipVrouterId:          masterVipVrouterIdVal,
		MetallbCidr:                 metallbCidrVal,
		MtuSize:                     mtuSizeVal,
		Name:                        nameVal,
		NetworkPlugin:               networkPluginVal,
		NodePoolName:                nodePoolNameVal,
		NodePoolUuid:                nodePoolUuidVal,
		NumMasters:                  numMastersVal,
		NumWorkers:                  numWorkersVal,
		Privileged:                  privilegedVal,
		ProjectId:                   projectIdVal,
		QuayPrivateRegistry:         quayPrivateRegistryVal,
		ReservedCpus:                reservedCpusVal,
		RuntimeConfig:               runtimeConfigVal,
		ServicesCidr:                servicesCidrVal,
		Status:                      statusVal,
		Tags:                        tagsVal,
		TaskError:                   taskErrorVal,
		TaskStatus:                  taskStatusVal,
		TopologyManagerPolicy:       topologyManagerPolicyVal,
		UseHostname:                 useHostnameVal,
		Uuid:                        uuidVal,
		WorkerStatus:                workerStatusVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewClustersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClustersValue {
	object, diags := NewClustersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClustersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClustersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClustersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClustersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClustersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClustersValueMust(ClustersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClustersType) ValueType(ctx context.Context) attr.Value {
	return ClustersValue{}
}

var _ basetypes.ObjectValuable = ClustersValue{}

type ClustersValue struct {
	AddonOperatorImageTag       basetypes.StringValue `tfsdk:"addon_operator_image_tag"`
	AllowWorkloadsOnMaster      basetypes.Int64Value  `tfsdk:"allow_workloads_on_master"`
	AppCatalogEnabled           basetypes.Int64Value  `tfsdk:"app_catalog_enabled"`
	AuthzEnabled                basetypes.Int64Value  `tfsdk:"authz_enabled"`
	CalicoControllerCpuLimit    basetypes.StringValue `tfsdk:"calico_controller_cpu_limit"`
	CalicoControllerMemoryLimit basetypes.StringValue `tfsdk:"calico_controller_memory_limit"`
	CalicoIpIpMode              basetypes.StringValue `tfsdk:"calico_ip_ip_mode"`
	CalicoNatOutgoing           basetypes.BoolValue   `tfsdk:"calico_nat_outgoing"`
	CalicoNodeCpuLimit          basetypes.StringValue `tfsdk:"calico_node_cpu_limit"`
	CalicoNodeMemoryLimit       basetypes.StringValue `tfsdk:"calico_node_memory_limit"`
	CalicoTyphaCpuLimit         basetypes.StringValue `tfsdk:"calico_typha_cpu_limit"`
	CalicoTyphaMemoryLimit      basetypes.StringValue `tfsdk:"calico_typha_memory_limit"`
	CalicoV4blockSize           basetypes.StringValue `tfsdk:"calico_v4block_size"`
	CanUpgrade                  basetypes.BoolValue   `tfsdk:"can_upgrade"`
	CertExpiryHrs               basetypes.Int64Value  `tfsdk:"cert_expiry_hrs"`
	CloudProperties             basetypes.ObjectValue `tfsdk:"cloud_properties"`
	CloudProviderName           basetypes.StringValue `tfsdk:"cloud_provider_name"`
	CloudProviderType           basetypes.StringValue `tfsdk:"cloud_provider_type"`
	CloudProviderUuid           basetypes.StringValue `tfsdk:"cloud_provider_uuid"`
	ContainerRuntime            basetypes.StringValue `tfsdk:"container_runtime"`
	ContainersCidr              basetypes.StringValue `tfsdk:"containers_cidr"`
	CpuManagerPolicy            basetypes.StringValue `tfsdk:"cpu_manager_policy"`
	DockerCentosPackageRepoUrl  basetypes.StringValue `tfsdk:"docker_centos_package_repo_url"`
	DockerPrivateRegistry       basetypes.StringValue `tfsdk:"docker_private_registry"`
	DockerRoot                  basetypes.StringValue `tfsdk:"docker_root"`
	DockerUbuntuPackageRepoUrl  basetypes.StringValue `tfsdk:"docker_ubuntu_package_repo_url"`
	EnableEtcdEncryption        basetypes.StringValue `tfsdk:"enable_etcd_encryption"`
	EnableMetallb               basetypes.BoolValue   `tfsdk:"enable_metallb"`
	EnableProfileAgent          basetypes.BoolValue   `tfsdk:"enable_profile_agent"`
	EtcdBackup                  basetypes.ObjectValue `tfsdk:"etcd_backup"`
	EtcdDataDir                 basetypes.StringValue `tfsdk:"etcd_data_dir"`
	ExternalDnsName             basetypes.StringValue `tfsdk:"external_dns_name"`
	FlannelIfaceLabel           basetypes.StringValue `tfsdk:"flannel_iface_label"`
	FlannelPublicIfaceLabel     basetypes.StringValue `tfsdk:"flannel_public_iface_label"`
	GcrPrivateRegistry          basetypes.StringValue `tfsdk:"gcr_private_registry"`
	IsKubernetes                basetypes.Int64Value  `tfsdk:"is_kubernetes"`
	K8sApiPort                  basetypes.StringValue `tfsdk:"k8s_api_port"`
	K8sPrivateRegistry          basetypes.StringValue `tfsdk:"k8s_private_registry"`
	KeystoneEnabled             basetypes.Int64Value  `tfsdk:"keystone_enabled"`
	LastOk                      basetypes.StringValue `tfsdk:"last_ok"`
	LastOp                      basetypes.StringValue `tfsdk:"last_op"`
	MasterIp                    basetypes.StringValue `tfsdk:"master_ip"`
	MasterStatus                basetypes.StringValue `tfsdk:"master_status"`
	MasterVipIface              basetypes.StringValue `tfsdk:"master_vip_iface"`
	MasterVipIpv4               basetypes.StringValue `tfsdk:"master_vip_ipv4"`
	MasterVipVrouterId          basetypes.StringValue `tfsdk:"master_vip_vrouter_id"`
	MetallbCidr                 basetypes.StringValue `tfsdk:"metallb_cidr"`
	MtuSize                     basetypes.StringValue `tfsdk:"mtu_size"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	NetworkPlugin               basetypes.StringValue `tfsdk:"network_plugin"`
	NodePoolName                basetypes.StringValue `tfsdk:"node_pool_name"`
	NodePoolUuid                basetypes.StringValue `tfsdk:"node_pool_uuid"`
	NumMasters                  basetypes.Int64Value  `tfsdk:"num_masters"`
	NumWorkers                  basetypes.Int64Value  `tfsdk:"num_workers"`
	Privileged                  basetypes.Int64Value  `tfsdk:"privileged"`
	ProjectId                   basetypes.StringValue `tfsdk:"project_id"`
	QuayPrivateRegistry         basetypes.StringValue `tfsdk:"quay_private_registry"`
	ReservedCpus                basetypes.StringValue `tfsdk:"reserved_cpus"`
	RuntimeConfig               basetypes.StringValue `tfsdk:"runtime_config"`
	ServicesCidr                basetypes.StringValue `tfsdk:"services_cidr"`
	Status                      basetypes.StringValue `tfsdk:"status"`
	Tags                        basetypes.ObjectValue `tfsdk:"tags"`
	TaskError                   basetypes.StringValue `tfsdk:"task_error"`
	TaskStatus                  basetypes.StringValue `tfsdk:"task_status"`
	TopologyManagerPolicy       basetypes.StringValue `tfsdk:"topology_manager_policy"`
	UseHostname                 basetypes.BoolValue   `tfsdk:"use_hostname"`
	Uuid                        basetypes.StringValue `tfsdk:"uuid"`
	WorkerStatus                basetypes.StringValue `tfsdk:"worker_status"`
	state                       attr.ValueState
}

func (v ClustersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 68)

	var val tftypes.Value
	var err error

	attrTypes["addon_operator_image_tag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allow_workloads_on_master"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["app_catalog_enabled"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["authz_enabled"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["calico_controller_cpu_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_controller_memory_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_ip_ip_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_nat_outgoing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["calico_node_cpu_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_node_memory_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_typha_cpu_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_typha_memory_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["calico_v4block_size"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["can_upgrade"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_expiry_hrs"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cloud_properties"] = basetypes.ObjectType{
		AttrTypes: CloudPropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cloud_provider_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_provider_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_provider_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container_runtime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["containers_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_manager_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_centos_package_repo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_private_registry"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_root"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_ubuntu_package_repo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enable_etcd_encryption"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enable_metallb"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_profile_agent"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["etcd_backup"] = basetypes.ObjectType{
		AttrTypes: EtcdBackupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["etcd_data_dir"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["flannel_iface_label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["flannel_public_iface_label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gcr_private_registry"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_kubernetes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["k8s_api_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["k8s_private_registry"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keystone_enabled"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_ok"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_op"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["master_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["master_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["master_vip_iface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["master_vip_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["master_vip_vrouter_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metallb_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu_size"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_plugin"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_pool_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_pool_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_masters"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_workers"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["privileged"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["project_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quay_private_registry"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reserved_cpus"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["runtime_config"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["services_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: TagsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["task_error"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["task_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["topology_manager_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_hostname"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["worker_status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 68)

		val, err = v.AddonOperatorImageTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addon_operator_image_tag"] = val

		val, err = v.AllowWorkloadsOnMaster.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_workloads_on_master"] = val

		val, err = v.AppCatalogEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_catalog_enabled"] = val

		val, err = v.AuthzEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authz_enabled"] = val

		val, err = v.CalicoControllerCpuLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_controller_cpu_limit"] = val

		val, err = v.CalicoControllerMemoryLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_controller_memory_limit"] = val

		val, err = v.CalicoIpIpMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_ip_ip_mode"] = val

		val, err = v.CalicoNatOutgoing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_nat_outgoing"] = val

		val, err = v.CalicoNodeCpuLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_node_cpu_limit"] = val

		val, err = v.CalicoNodeMemoryLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_node_memory_limit"] = val

		val, err = v.CalicoTyphaCpuLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_typha_cpu_limit"] = val

		val, err = v.CalicoTyphaMemoryLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_typha_memory_limit"] = val

		val, err = v.CalicoV4blockSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["calico_v4block_size"] = val

		val, err = v.CanUpgrade.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["can_upgrade"] = val

		val, err = v.CertExpiryHrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_expiry_hrs"] = val

		val, err = v.CloudProperties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_properties"] = val

		val, err = v.CloudProviderName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider_name"] = val

		val, err = v.CloudProviderType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider_type"] = val

		val, err = v.CloudProviderUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider_uuid"] = val

		val, err = v.ContainerRuntime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_runtime"] = val

		val, err = v.ContainersCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["containers_cidr"] = val

		val, err = v.CpuManagerPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_manager_policy"] = val

		val, err = v.DockerCentosPackageRepoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_centos_package_repo_url"] = val

		val, err = v.DockerPrivateRegistry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_private_registry"] = val

		val, err = v.DockerRoot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_root"] = val

		val, err = v.DockerUbuntuPackageRepoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_ubuntu_package_repo_url"] = val

		val, err = v.EnableEtcdEncryption.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_etcd_encryption"] = val

		val, err = v.EnableMetallb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_metallb"] = val

		val, err = v.EnableProfileAgent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_profile_agent"] = val

		val, err = v.EtcdBackup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["etcd_backup"] = val

		val, err = v.EtcdDataDir.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["etcd_data_dir"] = val

		val, err = v.ExternalDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns_name"] = val

		val, err = v.FlannelIfaceLabel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flannel_iface_label"] = val

		val, err = v.FlannelPublicIfaceLabel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flannel_public_iface_label"] = val

		val, err = v.GcrPrivateRegistry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gcr_private_registry"] = val

		val, err = v.IsKubernetes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_kubernetes"] = val

		val, err = v.K8sApiPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["k8s_api_port"] = val

		val, err = v.K8sPrivateRegistry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["k8s_private_registry"] = val

		val, err = v.KeystoneEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keystone_enabled"] = val

		val, err = v.LastOk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_ok"] = val

		val, err = v.LastOp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_op"] = val

		val, err = v.MasterIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_ip"] = val

		val, err = v.MasterStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_status"] = val

		val, err = v.MasterVipIface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_vip_iface"] = val

		val, err = v.MasterVipIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_vip_ipv4"] = val

		val, err = v.MasterVipVrouterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_vip_vrouter_id"] = val

		val, err = v.MetallbCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metallb_cidr"] = val

		val, err = v.MtuSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu_size"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetworkPlugin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_plugin"] = val

		val, err = v.NodePoolName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_pool_name"] = val

		val, err = v.NodePoolUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_pool_uuid"] = val

		val, err = v.NumMasters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_masters"] = val

		val, err = v.NumWorkers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_workers"] = val

		val, err = v.Privileged.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["privileged"] = val

		val, err = v.ProjectId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_id"] = val

		val, err = v.QuayPrivateRegistry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quay_private_registry"] = val

		val, err = v.ReservedCpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reserved_cpus"] = val

		val, err = v.RuntimeConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["runtime_config"] = val

		val, err = v.ServicesCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services_cidr"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.TaskError.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["task_error"] = val

		val, err = v.TaskStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["task_status"] = val

		val, err = v.TopologyManagerPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["topology_manager_policy"] = val

		val, err = v.UseHostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_hostname"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		val, err = v.WorkerStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["worker_status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClustersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClustersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClustersValue) String() string {
	return "ClustersValue"
}

func (v ClustersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cloudProperties basetypes.ObjectValue

	if v.CloudProperties.IsNull() {
		cloudProperties = types.ObjectNull(
			CloudPropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.CloudProperties.IsUnknown() {
		cloudProperties = types.ObjectUnknown(
			CloudPropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CloudProperties.IsNull() && !v.CloudProperties.IsUnknown() {
		cloudProperties = types.ObjectValueMust(
			CloudPropertiesValue{}.AttributeTypes(ctx),
			v.CloudProperties.Attributes(),
		)
	}

	var etcdBackup basetypes.ObjectValue

	if v.EtcdBackup.IsNull() {
		etcdBackup = types.ObjectNull(
			EtcdBackupValue{}.AttributeTypes(ctx),
		)
	}

	if v.EtcdBackup.IsUnknown() {
		etcdBackup = types.ObjectUnknown(
			EtcdBackupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EtcdBackup.IsNull() && !v.EtcdBackup.IsUnknown() {
		etcdBackup = types.ObjectValueMust(
			EtcdBackupValue{}.AttributeTypes(ctx),
			v.EtcdBackup.Attributes(),
		)
	}

	var tags basetypes.ObjectValue

	if v.Tags.IsNull() {
		tags = types.ObjectNull(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tags.IsUnknown() {
		tags = types.ObjectUnknown(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags.IsNull() && !v.Tags.IsUnknown() {
		tags = types.ObjectValueMust(
			TagsValue{}.AttributeTypes(ctx),
			v.Tags.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"addon_operator_image_tag":       basetypes.StringType{},
			"allow_workloads_on_master":      basetypes.Int64Type{},
			"app_catalog_enabled":            basetypes.Int64Type{},
			"authz_enabled":                  basetypes.Int64Type{},
			"calico_controller_cpu_limit":    basetypes.StringType{},
			"calico_controller_memory_limit": basetypes.StringType{},
			"calico_ip_ip_mode":              basetypes.StringType{},
			"calico_nat_outgoing":            basetypes.BoolType{},
			"calico_node_cpu_limit":          basetypes.StringType{},
			"calico_node_memory_limit":       basetypes.StringType{},
			"calico_typha_cpu_limit":         basetypes.StringType{},
			"calico_typha_memory_limit":      basetypes.StringType{},
			"calico_v4block_size":            basetypes.StringType{},
			"can_upgrade":                    basetypes.BoolType{},
			"cert_expiry_hrs":                basetypes.Int64Type{},
			"cloud_properties": basetypes.ObjectType{
				AttrTypes: CloudPropertiesValue{}.AttributeTypes(ctx),
			},
			"cloud_provider_name":            basetypes.StringType{},
			"cloud_provider_type":            basetypes.StringType{},
			"cloud_provider_uuid":            basetypes.StringType{},
			"container_runtime":              basetypes.StringType{},
			"containers_cidr":                basetypes.StringType{},
			"cpu_manager_policy":             basetypes.StringType{},
			"docker_centos_package_repo_url": basetypes.StringType{},
			"docker_private_registry":        basetypes.StringType{},
			"docker_root":                    basetypes.StringType{},
			"docker_ubuntu_package_repo_url": basetypes.StringType{},
			"enable_etcd_encryption":         basetypes.StringType{},
			"enable_metallb":                 basetypes.BoolType{},
			"enable_profile_agent":           basetypes.BoolType{},
			"etcd_backup": basetypes.ObjectType{
				AttrTypes: EtcdBackupValue{}.AttributeTypes(ctx),
			},
			"etcd_data_dir":              basetypes.StringType{},
			"external_dns_name":          basetypes.StringType{},
			"flannel_iface_label":        basetypes.StringType{},
			"flannel_public_iface_label": basetypes.StringType{},
			"gcr_private_registry":       basetypes.StringType{},
			"is_kubernetes":              basetypes.Int64Type{},
			"k8s_api_port":               basetypes.StringType{},
			"k8s_private_registry":       basetypes.StringType{},
			"keystone_enabled":           basetypes.Int64Type{},
			"last_ok":                    basetypes.StringType{},
			"last_op":                    basetypes.StringType{},
			"master_ip":                  basetypes.StringType{},
			"master_status":              basetypes.StringType{},
			"master_vip_iface":           basetypes.StringType{},
			"master_vip_ipv4":            basetypes.StringType{},
			"master_vip_vrouter_id":      basetypes.StringType{},
			"metallb_cidr":               basetypes.StringType{},
			"mtu_size":                   basetypes.StringType{},
			"name":                       basetypes.StringType{},
			"network_plugin":             basetypes.StringType{},
			"node_pool_name":             basetypes.StringType{},
			"node_pool_uuid":             basetypes.StringType{},
			"num_masters":                basetypes.Int64Type{},
			"num_workers":                basetypes.Int64Type{},
			"privileged":                 basetypes.Int64Type{},
			"project_id":                 basetypes.StringType{},
			"quay_private_registry":      basetypes.StringType{},
			"reserved_cpus":              basetypes.StringType{},
			"runtime_config":             basetypes.StringType{},
			"services_cidr":              basetypes.StringType{},
			"status":                     basetypes.StringType{},
			"tags": basetypes.ObjectType{
				AttrTypes: TagsValue{}.AttributeTypes(ctx),
			},
			"task_error":              basetypes.StringType{},
			"task_status":             basetypes.StringType{},
			"topology_manager_policy": basetypes.StringType{},
			"use_hostname":            basetypes.BoolType{},
			"uuid":                    basetypes.StringType{},
			"worker_status":           basetypes.StringType{},
		},
		map[string]attr.Value{
			"addon_operator_image_tag":       v.AddonOperatorImageTag,
			"allow_workloads_on_master":      v.AllowWorkloadsOnMaster,
			"app_catalog_enabled":            v.AppCatalogEnabled,
			"authz_enabled":                  v.AuthzEnabled,
			"calico_controller_cpu_limit":    v.CalicoControllerCpuLimit,
			"calico_controller_memory_limit": v.CalicoControllerMemoryLimit,
			"calico_ip_ip_mode":              v.CalicoIpIpMode,
			"calico_nat_outgoing":            v.CalicoNatOutgoing,
			"calico_node_cpu_limit":          v.CalicoNodeCpuLimit,
			"calico_node_memory_limit":       v.CalicoNodeMemoryLimit,
			"calico_typha_cpu_limit":         v.CalicoTyphaCpuLimit,
			"calico_typha_memory_limit":      v.CalicoTyphaMemoryLimit,
			"calico_v4block_size":            v.CalicoV4blockSize,
			"can_upgrade":                    v.CanUpgrade,
			"cert_expiry_hrs":                v.CertExpiryHrs,
			"cloud_properties":               cloudProperties,
			"cloud_provider_name":            v.CloudProviderName,
			"cloud_provider_type":            v.CloudProviderType,
			"cloud_provider_uuid":            v.CloudProviderUuid,
			"container_runtime":              v.ContainerRuntime,
			"containers_cidr":                v.ContainersCidr,
			"cpu_manager_policy":             v.CpuManagerPolicy,
			"docker_centos_package_repo_url": v.DockerCentosPackageRepoUrl,
			"docker_private_registry":        v.DockerPrivateRegistry,
			"docker_root":                    v.DockerRoot,
			"docker_ubuntu_package_repo_url": v.DockerUbuntuPackageRepoUrl,
			"enable_etcd_encryption":         v.EnableEtcdEncryption,
			"enable_metallb":                 v.EnableMetallb,
			"enable_profile_agent":           v.EnableProfileAgent,
			"etcd_backup":                    etcdBackup,
			"etcd_data_dir":                  v.EtcdDataDir,
			"external_dns_name":              v.ExternalDnsName,
			"flannel_iface_label":            v.FlannelIfaceLabel,
			"flannel_public_iface_label":     v.FlannelPublicIfaceLabel,
			"gcr_private_registry":           v.GcrPrivateRegistry,
			"is_kubernetes":                  v.IsKubernetes,
			"k8s_api_port":                   v.K8sApiPort,
			"k8s_private_registry":           v.K8sPrivateRegistry,
			"keystone_enabled":               v.KeystoneEnabled,
			"last_ok":                        v.LastOk,
			"last_op":                        v.LastOp,
			"master_ip":                      v.MasterIp,
			"master_status":                  v.MasterStatus,
			"master_vip_iface":               v.MasterVipIface,
			"master_vip_ipv4":                v.MasterVipIpv4,
			"master_vip_vrouter_id":          v.MasterVipVrouterId,
			"metallb_cidr":                   v.MetallbCidr,
			"mtu_size":                       v.MtuSize,
			"name":                           v.Name,
			"network_plugin":                 v.NetworkPlugin,
			"node_pool_name":                 v.NodePoolName,
			"node_pool_uuid":                 v.NodePoolUuid,
			"num_masters":                    v.NumMasters,
			"num_workers":                    v.NumWorkers,
			"privileged":                     v.Privileged,
			"project_id":                     v.ProjectId,
			"quay_private_registry":          v.QuayPrivateRegistry,
			"reserved_cpus":                  v.ReservedCpus,
			"runtime_config":                 v.RuntimeConfig,
			"services_cidr":                  v.ServicesCidr,
			"status":                         v.Status,
			"tags":                           tags,
			"task_error":                     v.TaskError,
			"task_status":                    v.TaskStatus,
			"topology_manager_policy":        v.TopologyManagerPolicy,
			"use_hostname":                   v.UseHostname,
			"uuid":                           v.Uuid,
			"worker_status":                  v.WorkerStatus,
		})

	return objVal, diags
}

func (v ClustersValue) Equal(o attr.Value) bool {
	other, ok := o.(ClustersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddonOperatorImageTag.Equal(other.AddonOperatorImageTag) {
		return false
	}

	if !v.AllowWorkloadsOnMaster.Equal(other.AllowWorkloadsOnMaster) {
		return false
	}

	if !v.AppCatalogEnabled.Equal(other.AppCatalogEnabled) {
		return false
	}

	if !v.AuthzEnabled.Equal(other.AuthzEnabled) {
		return false
	}

	if !v.CalicoControllerCpuLimit.Equal(other.CalicoControllerCpuLimit) {
		return false
	}

	if !v.CalicoControllerMemoryLimit.Equal(other.CalicoControllerMemoryLimit) {
		return false
	}

	if !v.CalicoIpIpMode.Equal(other.CalicoIpIpMode) {
		return false
	}

	if !v.CalicoNatOutgoing.Equal(other.CalicoNatOutgoing) {
		return false
	}

	if !v.CalicoNodeCpuLimit.Equal(other.CalicoNodeCpuLimit) {
		return false
	}

	if !v.CalicoNodeMemoryLimit.Equal(other.CalicoNodeMemoryLimit) {
		return false
	}

	if !v.CalicoTyphaCpuLimit.Equal(other.CalicoTyphaCpuLimit) {
		return false
	}

	if !v.CalicoTyphaMemoryLimit.Equal(other.CalicoTyphaMemoryLimit) {
		return false
	}

	if !v.CalicoV4blockSize.Equal(other.CalicoV4blockSize) {
		return false
	}

	if !v.CanUpgrade.Equal(other.CanUpgrade) {
		return false
	}

	if !v.CertExpiryHrs.Equal(other.CertExpiryHrs) {
		return false
	}

	if !v.CloudProperties.Equal(other.CloudProperties) {
		return false
	}

	if !v.CloudProviderName.Equal(other.CloudProviderName) {
		return false
	}

	if !v.CloudProviderType.Equal(other.CloudProviderType) {
		return false
	}

	if !v.CloudProviderUuid.Equal(other.CloudProviderUuid) {
		return false
	}

	if !v.ContainerRuntime.Equal(other.ContainerRuntime) {
		return false
	}

	if !v.ContainersCidr.Equal(other.ContainersCidr) {
		return false
	}

	if !v.CpuManagerPolicy.Equal(other.CpuManagerPolicy) {
		return false
	}

	if !v.DockerCentosPackageRepoUrl.Equal(other.DockerCentosPackageRepoUrl) {
		return false
	}

	if !v.DockerPrivateRegistry.Equal(other.DockerPrivateRegistry) {
		return false
	}

	if !v.DockerRoot.Equal(other.DockerRoot) {
		return false
	}

	if !v.DockerUbuntuPackageRepoUrl.Equal(other.DockerUbuntuPackageRepoUrl) {
		return false
	}

	if !v.EnableEtcdEncryption.Equal(other.EnableEtcdEncryption) {
		return false
	}

	if !v.EnableMetallb.Equal(other.EnableMetallb) {
		return false
	}

	if !v.EnableProfileAgent.Equal(other.EnableProfileAgent) {
		return false
	}

	if !v.EtcdBackup.Equal(other.EtcdBackup) {
		return false
	}

	if !v.EtcdDataDir.Equal(other.EtcdDataDir) {
		return false
	}

	if !v.ExternalDnsName.Equal(other.ExternalDnsName) {
		return false
	}

	if !v.FlannelIfaceLabel.Equal(other.FlannelIfaceLabel) {
		return false
	}

	if !v.FlannelPublicIfaceLabel.Equal(other.FlannelPublicIfaceLabel) {
		return false
	}

	if !v.GcrPrivateRegistry.Equal(other.GcrPrivateRegistry) {
		return false
	}

	if !v.IsKubernetes.Equal(other.IsKubernetes) {
		return false
	}

	if !v.K8sApiPort.Equal(other.K8sApiPort) {
		return false
	}

	if !v.K8sPrivateRegistry.Equal(other.K8sPrivateRegistry) {
		return false
	}

	if !v.KeystoneEnabled.Equal(other.KeystoneEnabled) {
		return false
	}

	if !v.LastOk.Equal(other.LastOk) {
		return false
	}

	if !v.LastOp.Equal(other.LastOp) {
		return false
	}

	if !v.MasterIp.Equal(other.MasterIp) {
		return false
	}

	if !v.MasterStatus.Equal(other.MasterStatus) {
		return false
	}

	if !v.MasterVipIface.Equal(other.MasterVipIface) {
		return false
	}

	if !v.MasterVipIpv4.Equal(other.MasterVipIpv4) {
		return false
	}

	if !v.MasterVipVrouterId.Equal(other.MasterVipVrouterId) {
		return false
	}

	if !v.MetallbCidr.Equal(other.MetallbCidr) {
		return false
	}

	if !v.MtuSize.Equal(other.MtuSize) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetworkPlugin.Equal(other.NetworkPlugin) {
		return false
	}

	if !v.NodePoolName.Equal(other.NodePoolName) {
		return false
	}

	if !v.NodePoolUuid.Equal(other.NodePoolUuid) {
		return false
	}

	if !v.NumMasters.Equal(other.NumMasters) {
		return false
	}

	if !v.NumWorkers.Equal(other.NumWorkers) {
		return false
	}

	if !v.Privileged.Equal(other.Privileged) {
		return false
	}

	if !v.ProjectId.Equal(other.ProjectId) {
		return false
	}

	if !v.QuayPrivateRegistry.Equal(other.QuayPrivateRegistry) {
		return false
	}

	if !v.ReservedCpus.Equal(other.ReservedCpus) {
		return false
	}

	if !v.RuntimeConfig.Equal(other.RuntimeConfig) {
		return false
	}

	if !v.ServicesCidr.Equal(other.ServicesCidr) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.TaskError.Equal(other.TaskError) {
		return false
	}

	if !v.TaskStatus.Equal(other.TaskStatus) {
		return false
	}

	if !v.TopologyManagerPolicy.Equal(other.TopologyManagerPolicy) {
		return false
	}

	if !v.UseHostname.Equal(other.UseHostname) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	if !v.WorkerStatus.Equal(other.WorkerStatus) {
		return false
	}

	return true
}

func (v ClustersValue) Type(ctx context.Context) attr.Type {
	return ClustersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClustersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"addon_operator_image_tag":       basetypes.StringType{},
		"allow_workloads_on_master":      basetypes.Int64Type{},
		"app_catalog_enabled":            basetypes.Int64Type{},
		"authz_enabled":                  basetypes.Int64Type{},
		"calico_controller_cpu_limit":    basetypes.StringType{},
		"calico_controller_memory_limit": basetypes.StringType{},
		"calico_ip_ip_mode":              basetypes.StringType{},
		"calico_nat_outgoing":            basetypes.BoolType{},
		"calico_node_cpu_limit":          basetypes.StringType{},
		"calico_node_memory_limit":       basetypes.StringType{},
		"calico_typha_cpu_limit":         basetypes.StringType{},
		"calico_typha_memory_limit":      basetypes.StringType{},
		"calico_v4block_size":            basetypes.StringType{},
		"can_upgrade":                    basetypes.BoolType{},
		"cert_expiry_hrs":                basetypes.Int64Type{},
		"cloud_properties": basetypes.ObjectType{
			AttrTypes: CloudPropertiesValue{}.AttributeTypes(ctx),
		},
		"cloud_provider_name":            basetypes.StringType{},
		"cloud_provider_type":            basetypes.StringType{},
		"cloud_provider_uuid":            basetypes.StringType{},
		"container_runtime":              basetypes.StringType{},
		"containers_cidr":                basetypes.StringType{},
		"cpu_manager_policy":             basetypes.StringType{},
		"docker_centos_package_repo_url": basetypes.StringType{},
		"docker_private_registry":        basetypes.StringType{},
		"docker_root":                    basetypes.StringType{},
		"docker_ubuntu_package_repo_url": basetypes.StringType{},
		"enable_etcd_encryption":         basetypes.StringType{},
		"enable_metallb":                 basetypes.BoolType{},
		"enable_profile_agent":           basetypes.BoolType{},
		"etcd_backup": basetypes.ObjectType{
			AttrTypes: EtcdBackupValue{}.AttributeTypes(ctx),
		},
		"etcd_data_dir":              basetypes.StringType{},
		"external_dns_name":          basetypes.StringType{},
		"flannel_iface_label":        basetypes.StringType{},
		"flannel_public_iface_label": basetypes.StringType{},
		"gcr_private_registry":       basetypes.StringType{},
		"is_kubernetes":              basetypes.Int64Type{},
		"k8s_api_port":               basetypes.StringType{},
		"k8s_private_registry":       basetypes.StringType{},
		"keystone_enabled":           basetypes.Int64Type{},
		"last_ok":                    basetypes.StringType{},
		"last_op":                    basetypes.StringType{},
		"master_ip":                  basetypes.StringType{},
		"master_status":              basetypes.StringType{},
		"master_vip_iface":           basetypes.StringType{},
		"master_vip_ipv4":            basetypes.StringType{},
		"master_vip_vrouter_id":      basetypes.StringType{},
		"metallb_cidr":               basetypes.StringType{},
		"mtu_size":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"network_plugin":             basetypes.StringType{},
		"node_pool_name":             basetypes.StringType{},
		"node_pool_uuid":             basetypes.StringType{},
		"num_masters":                basetypes.Int64Type{},
		"num_workers":                basetypes.Int64Type{},
		"privileged":                 basetypes.Int64Type{},
		"project_id":                 basetypes.StringType{},
		"quay_private_registry":      basetypes.StringType{},
		"reserved_cpus":              basetypes.StringType{},
		"runtime_config":             basetypes.StringType{},
		"services_cidr":              basetypes.StringType{},
		"status":                     basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
		"task_error":              basetypes.StringType{},
		"task_status":             basetypes.StringType{},
		"topology_manager_policy": basetypes.StringType{},
		"use_hostname":            basetypes.BoolType{},
		"uuid":                    basetypes.StringType{},
		"worker_status":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CloudPropertiesType{}

type CloudPropertiesType struct {
	basetypes.ObjectType
}

func (t CloudPropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(CloudPropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloudPropertiesType) String() string {
	return "CloudPropertiesType"
}

func (t CloudPropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return nil, diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	azsAttribute, ok := attributes["azs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azs is missing from object`)

		return nil, diags
	}

	azsVal, ok := azsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azs expected to be basetypes.ListValue, was: %T`, azsAttribute))
	}

	customAmiAttribute, ok := attributes["custom_ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ami is missing from object`)

		return nil, diags
	}

	customAmiVal, ok := customAmiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ami expected to be basetypes.StringValue, was: %T`, customAmiAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return nil, diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	httpProxyAttribute, ok := attributes["http_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_proxy is missing from object`)

		return nil, diags
	}

	httpProxyVal, ok := httpProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_proxy expected to be basetypes.StringValue, was: %T`, httpProxyAttribute))
	}

	internalElbAttribute, ok := attributes["internal_elb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_elb is missing from object`)

		return nil, diags
	}

	internalElbVal, ok := internalElbAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_elb expected to be basetypes.BoolValue, was: %T`, internalElbAttribute))
	}

	isPrivateAttribute, ok := attributes["is_private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_private is missing from object`)

		return nil, diags
	}

	isPrivateVal, ok := isPrivateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_private expected to be basetypes.BoolValue, was: %T`, isPrivateAttribute))
	}

	masterFlavorAttribute, ok := attributes["master_flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_flavor is missing from object`)

		return nil, diags
	}

	masterFlavorVal, ok := masterFlavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_flavor expected to be basetypes.StringValue, was: %T`, masterFlavorAttribute))
	}

	privateSubnetsAttribute, ok := attributes["private_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_subnets is missing from object`)

		return nil, diags
	}

	privateSubnetsVal, ok := privateSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_subnets expected to be basetypes.ListValue, was: %T`, privateSubnetsAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	serviceFqdnAttribute, ok := attributes["service_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_fqdn is missing from object`)

		return nil, diags
	}

	serviceFqdnVal, ok := serviceFqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_fqdn expected to be basetypes.StringValue, was: %T`, serviceFqdnAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return nil, diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	usePf9domainAttribute, ok := attributes["use_pf9domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_pf9domain is missing from object`)

		return nil, diags
	}

	usePf9domainVal, ok := usePf9domainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_pf9domain expected to be basetypes.StringValue, was: %T`, usePf9domainAttribute))
	}

	vpcAttribute, ok := attributes["vpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc is missing from object`)

		return nil, diags
	}

	vpcVal, ok := vpcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc expected to be basetypes.StringValue, was: %T`, vpcAttribute))
	}

	workerFlavorAttribute, ok := attributes["worker_flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_flavor is missing from object`)

		return nil, diags
	}

	workerFlavorVal, ok := workerFlavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_flavor expected to be basetypes.StringValue, was: %T`, workerFlavorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloudPropertiesValue{
		Ami:            amiVal,
		Azs:            azsVal,
		CustomAmi:      customAmiVal,
		DomainId:       domainIdVal,
		HttpProxy:      httpProxyVal,
		InternalElb:    internalElbVal,
		IsPrivate:      isPrivateVal,
		MasterFlavor:   masterFlavorVal,
		PrivateSubnets: privateSubnetsVal,
		Region:         regionVal,
		ServiceFqdn:    serviceFqdnVal,
		SshKey:         sshKeyVal,
		Subnets:        subnetsVal,
		UsePf9domain:   usePf9domainVal,
		Vpc:            vpcVal,
		WorkerFlavor:   workerFlavorVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCloudPropertiesValueNull() CloudPropertiesValue {
	return CloudPropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewCloudPropertiesValueUnknown() CloudPropertiesValue {
	return CloudPropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloudPropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloudPropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloudPropertiesValue Attribute Value",
				"While creating a CloudPropertiesValue value, a missing attribute value was detected. "+
					"A CloudPropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudPropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloudPropertiesValue Attribute Type",
				"While creating a CloudPropertiesValue value, an invalid attribute value was detected. "+
					"A CloudPropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudPropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloudPropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloudPropertiesValue Attribute Value",
				"While creating a CloudPropertiesValue value, an extra attribute value was detected. "+
					"A CloudPropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloudPropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloudPropertiesValueUnknown(), diags
	}

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	azsAttribute, ok := attributes["azs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azs is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	azsVal, ok := azsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azs expected to be basetypes.ListValue, was: %T`, azsAttribute))
	}

	customAmiAttribute, ok := attributes["custom_ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ami is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	customAmiVal, ok := customAmiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ami expected to be basetypes.StringValue, was: %T`, customAmiAttribute))
	}

	domainIdAttribute, ok := attributes["domain_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_id is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	domainIdVal, ok := domainIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_id expected to be basetypes.StringValue, was: %T`, domainIdAttribute))
	}

	httpProxyAttribute, ok := attributes["http_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_proxy is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	httpProxyVal, ok := httpProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_proxy expected to be basetypes.StringValue, was: %T`, httpProxyAttribute))
	}

	internalElbAttribute, ok := attributes["internal_elb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_elb is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	internalElbVal, ok := internalElbAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_elb expected to be basetypes.BoolValue, was: %T`, internalElbAttribute))
	}

	isPrivateAttribute, ok := attributes["is_private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_private is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	isPrivateVal, ok := isPrivateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_private expected to be basetypes.BoolValue, was: %T`, isPrivateAttribute))
	}

	masterFlavorAttribute, ok := attributes["master_flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`master_flavor is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	masterFlavorVal, ok := masterFlavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`master_flavor expected to be basetypes.StringValue, was: %T`, masterFlavorAttribute))
	}

	privateSubnetsAttribute, ok := attributes["private_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_subnets is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	privateSubnetsVal, ok := privateSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_subnets expected to be basetypes.ListValue, was: %T`, privateSubnetsAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	serviceFqdnAttribute, ok := attributes["service_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_fqdn is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	serviceFqdnVal, ok := serviceFqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_fqdn expected to be basetypes.StringValue, was: %T`, serviceFqdnAttribute))
	}

	sshKeyAttribute, ok := attributes["ssh_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_key is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	sshKeyVal, ok := sshKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_key expected to be basetypes.StringValue, was: %T`, sshKeyAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	usePf9domainAttribute, ok := attributes["use_pf9domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_pf9domain is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	usePf9domainVal, ok := usePf9domainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_pf9domain expected to be basetypes.StringValue, was: %T`, usePf9domainAttribute))
	}

	vpcAttribute, ok := attributes["vpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	vpcVal, ok := vpcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc expected to be basetypes.StringValue, was: %T`, vpcAttribute))
	}

	workerFlavorAttribute, ok := attributes["worker_flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_flavor is missing from object`)

		return NewCloudPropertiesValueUnknown(), diags
	}

	workerFlavorVal, ok := workerFlavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_flavor expected to be basetypes.StringValue, was: %T`, workerFlavorAttribute))
	}

	if diags.HasError() {
		return NewCloudPropertiesValueUnknown(), diags
	}

	return CloudPropertiesValue{
		Ami:            amiVal,
		Azs:            azsVal,
		CustomAmi:      customAmiVal,
		DomainId:       domainIdVal,
		HttpProxy:      httpProxyVal,
		InternalElb:    internalElbVal,
		IsPrivate:      isPrivateVal,
		MasterFlavor:   masterFlavorVal,
		PrivateSubnets: privateSubnetsVal,
		Region:         regionVal,
		ServiceFqdn:    serviceFqdnVal,
		SshKey:         sshKeyVal,
		Subnets:        subnetsVal,
		UsePf9domain:   usePf9domainVal,
		Vpc:            vpcVal,
		WorkerFlavor:   workerFlavorVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCloudPropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloudPropertiesValue {
	object, diags := NewCloudPropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloudPropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloudPropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloudPropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloudPropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloudPropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloudPropertiesValueMust(CloudPropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloudPropertiesType) ValueType(ctx context.Context) attr.Value {
	return CloudPropertiesValue{}
}

var _ basetypes.ObjectValuable = CloudPropertiesValue{}

type CloudPropertiesValue struct {
	Ami            basetypes.StringValue `tfsdk:"ami"`
	Azs            basetypes.ListValue   `tfsdk:"azs"`
	CustomAmi      basetypes.StringValue `tfsdk:"custom_ami"`
	DomainId       basetypes.StringValue `tfsdk:"domain_id"`
	HttpProxy      basetypes.StringValue `tfsdk:"http_proxy"`
	InternalElb    basetypes.BoolValue   `tfsdk:"internal_elb"`
	IsPrivate      basetypes.BoolValue   `tfsdk:"is_private"`
	MasterFlavor   basetypes.StringValue `tfsdk:"master_flavor"`
	PrivateSubnets basetypes.ListValue   `tfsdk:"private_subnets"`
	Region         basetypes.StringValue `tfsdk:"region"`
	ServiceFqdn    basetypes.StringValue `tfsdk:"service_fqdn"`
	SshKey         basetypes.StringValue `tfsdk:"ssh_key"`
	Subnets        basetypes.ListValue   `tfsdk:"subnets"`
	UsePf9domain   basetypes.StringValue `tfsdk:"use_pf9domain"`
	Vpc            basetypes.StringValue `tfsdk:"vpc"`
	WorkerFlavor   basetypes.StringValue `tfsdk:"worker_flavor"`
	state          attr.ValueState
}

func (v CloudPropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["custom_ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["http_proxy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal_elb"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_private"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["master_flavor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_fqdn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["use_pf9domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpc"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["worker_flavor"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Ami.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami"] = val

		val, err = v.Azs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azs"] = val

		val, err = v.CustomAmi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ami"] = val

		val, err = v.DomainId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_id"] = val

		val, err = v.HttpProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_proxy"] = val

		val, err = v.InternalElb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_elb"] = val

		val, err = v.IsPrivate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_private"] = val

		val, err = v.MasterFlavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["master_flavor"] = val

		val, err = v.PrivateSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_subnets"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.ServiceFqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_fqdn"] = val

		val, err = v.SshKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_key"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.UsePf9domain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_pf9domain"] = val

		val, err = v.Vpc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc"] = val

		val, err = v.WorkerFlavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["worker_flavor"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloudPropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloudPropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloudPropertiesValue) String() string {
	return "CloudPropertiesValue"
}

func (v CloudPropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	azsVal, d := types.ListValue(types.StringType, v.Azs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami": basetypes.StringType{},
			"azs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom_ami":    basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"http_proxy":    basetypes.StringType{},
			"internal_elb":  basetypes.BoolType{},
			"is_private":    basetypes.BoolType{},
			"master_flavor": basetypes.StringType{},
			"private_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"region":       basetypes.StringType{},
			"service_fqdn": basetypes.StringType{},
			"ssh_key":      basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_pf9domain": basetypes.StringType{},
			"vpc":           basetypes.StringType{},
			"worker_flavor": basetypes.StringType{},
		}), diags
	}

	privateSubnetsVal, d := types.ListValue(types.StringType, v.PrivateSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami": basetypes.StringType{},
			"azs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom_ami":    basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"http_proxy":    basetypes.StringType{},
			"internal_elb":  basetypes.BoolType{},
			"is_private":    basetypes.BoolType{},
			"master_flavor": basetypes.StringType{},
			"private_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"region":       basetypes.StringType{},
			"service_fqdn": basetypes.StringType{},
			"ssh_key":      basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_pf9domain": basetypes.StringType{},
			"vpc":           basetypes.StringType{},
			"worker_flavor": basetypes.StringType{},
		}), diags
	}

	subnetsVal, d := types.ListValue(types.StringType, v.Subnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami": basetypes.StringType{},
			"azs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom_ami":    basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"http_proxy":    basetypes.StringType{},
			"internal_elb":  basetypes.BoolType{},
			"is_private":    basetypes.BoolType{},
			"master_flavor": basetypes.StringType{},
			"private_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"region":       basetypes.StringType{},
			"service_fqdn": basetypes.StringType{},
			"ssh_key":      basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_pf9domain": basetypes.StringType{},
			"vpc":           basetypes.StringType{},
			"worker_flavor": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ami": basetypes.StringType{},
			"azs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom_ami":    basetypes.StringType{},
			"domain_id":     basetypes.StringType{},
			"http_proxy":    basetypes.StringType{},
			"internal_elb":  basetypes.BoolType{},
			"is_private":    basetypes.BoolType{},
			"master_flavor": basetypes.StringType{},
			"private_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"region":       basetypes.StringType{},
			"service_fqdn": basetypes.StringType{},
			"ssh_key":      basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_pf9domain": basetypes.StringType{},
			"vpc":           basetypes.StringType{},
			"worker_flavor": basetypes.StringType{},
		},
		map[string]attr.Value{
			"ami":             v.Ami,
			"azs":             azsVal,
			"custom_ami":      v.CustomAmi,
			"domain_id":       v.DomainId,
			"http_proxy":      v.HttpProxy,
			"internal_elb":    v.InternalElb,
			"is_private":      v.IsPrivate,
			"master_flavor":   v.MasterFlavor,
			"private_subnets": privateSubnetsVal,
			"region":          v.Region,
			"service_fqdn":    v.ServiceFqdn,
			"ssh_key":         v.SshKey,
			"subnets":         subnetsVal,
			"use_pf9domain":   v.UsePf9domain,
			"vpc":             v.Vpc,
			"worker_flavor":   v.WorkerFlavor,
		})

	return objVal, diags
}

func (v CloudPropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(CloudPropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ami.Equal(other.Ami) {
		return false
	}

	if !v.Azs.Equal(other.Azs) {
		return false
	}

	if !v.CustomAmi.Equal(other.CustomAmi) {
		return false
	}

	if !v.DomainId.Equal(other.DomainId) {
		return false
	}

	if !v.HttpProxy.Equal(other.HttpProxy) {
		return false
	}

	if !v.InternalElb.Equal(other.InternalElb) {
		return false
	}

	if !v.IsPrivate.Equal(other.IsPrivate) {
		return false
	}

	if !v.MasterFlavor.Equal(other.MasterFlavor) {
		return false
	}

	if !v.PrivateSubnets.Equal(other.PrivateSubnets) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.ServiceFqdn.Equal(other.ServiceFqdn) {
		return false
	}

	if !v.SshKey.Equal(other.SshKey) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.UsePf9domain.Equal(other.UsePf9domain) {
		return false
	}

	if !v.Vpc.Equal(other.Vpc) {
		return false
	}

	if !v.WorkerFlavor.Equal(other.WorkerFlavor) {
		return false
	}

	return true
}

func (v CloudPropertiesValue) Type(ctx context.Context) attr.Type {
	return CloudPropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloudPropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami": basetypes.StringType{},
		"azs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom_ami":    basetypes.StringType{},
		"domain_id":     basetypes.StringType{},
		"http_proxy":    basetypes.StringType{},
		"internal_elb":  basetypes.BoolType{},
		"is_private":    basetypes.BoolType{},
		"master_flavor": basetypes.StringType{},
		"private_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"region":       basetypes.StringType{},
		"service_fqdn": basetypes.StringType{},
		"ssh_key":      basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"use_pf9domain": basetypes.StringType{},
		"vpc":           basetypes.StringType{},
		"worker_flavor": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EtcdBackupType{}

type EtcdBackupType struct {
	basetypes.ObjectType
}

func (t EtcdBackupType) Equal(o attr.Type) bool {
	other, ok := o.(EtcdBackupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EtcdBackupType) String() string {
	return "EtcdBackupType"
}

func (t EtcdBackupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dailyBackupTimeAttribute, ok := attributes["daily_backup_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backup_time is missing from object`)

		return nil, diags
	}

	dailyBackupTimeVal, ok := dailyBackupTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backup_time expected to be basetypes.StringValue, was: %T`, dailyBackupTimeAttribute))
	}

	intervalInHoursAttribute, ok := attributes["interval_in_hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval_in_hours is missing from object`)

		return nil, diags
	}

	intervalInHoursVal, ok := intervalInHoursAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval_in_hours expected to be basetypes.Int64Value, was: %T`, intervalInHoursAttribute))
	}

	intervalInMinsAttribute, ok := attributes["interval_in_mins"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval_in_mins is missing from object`)

		return nil, diags
	}

	intervalInMinsVal, ok := intervalInMinsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval_in_mins expected to be basetypes.Int64Value, was: %T`, intervalInMinsAttribute))
	}

	isEtcdBackupEnabledAttribute, ok := attributes["is_etcd_backup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_etcd_backup_enabled is missing from object`)

		return nil, diags
	}

	isEtcdBackupEnabledVal, ok := isEtcdBackupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_etcd_backup_enabled expected to be basetypes.BoolValue, was: %T`, isEtcdBackupEnabledAttribute))
	}

	maxIntervalBackupCountAttribute, ok := attributes["max_interval_backup_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_interval_backup_count is missing from object`)

		return nil, diags
	}

	maxIntervalBackupCountVal, ok := maxIntervalBackupCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_interval_backup_count expected to be basetypes.Int64Value, was: %T`, maxIntervalBackupCountAttribute))
	}

	maxTimestampBackupCountAttribute, ok := attributes["max_timestamp_backup_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_timestamp_backup_count is missing from object`)

		return nil, diags
	}

	maxTimestampBackupCountVal, ok := maxTimestampBackupCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_timestamp_backup_count expected to be basetypes.Int64Value, was: %T`, maxTimestampBackupCountAttribute))
	}

	storagePropertiesAttribute, ok := attributes["storage_properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_properties is missing from object`)

		return nil, diags
	}

	storagePropertiesVal, ok := storagePropertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_properties expected to be basetypes.ObjectValue, was: %T`, storagePropertiesAttribute))
	}

	storageTypeAttribute, ok := attributes["storage_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_type is missing from object`)

		return nil, diags
	}

	storageTypeVal, ok := storageTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_type expected to be basetypes.StringValue, was: %T`, storageTypeAttribute))
	}

	taskErrorDetailAttribute, ok := attributes["task_error_detail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_error_detail is missing from object`)

		return nil, diags
	}

	taskErrorDetailVal, ok := taskErrorDetailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_error_detail expected to be basetypes.StringValue, was: %T`, taskErrorDetailAttribute))
	}

	taskStatusAttribute, ok := attributes["task_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_status is missing from object`)

		return nil, diags
	}

	taskStatusVal, ok := taskStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_status expected to be basetypes.StringValue, was: %T`, taskStatusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EtcdBackupValue{
		DailyBackupTime:         dailyBackupTimeVal,
		IntervalInHours:         intervalInHoursVal,
		IntervalInMins:          intervalInMinsVal,
		IsEtcdBackupEnabled:     isEtcdBackupEnabledVal,
		MaxIntervalBackupCount:  maxIntervalBackupCountVal,
		MaxTimestampBackupCount: maxTimestampBackupCountVal,
		StorageProperties:       storagePropertiesVal,
		StorageType:             storageTypeVal,
		TaskErrorDetail:         taskErrorDetailVal,
		TaskStatus:              taskStatusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewEtcdBackupValueNull() EtcdBackupValue {
	return EtcdBackupValue{
		state: attr.ValueStateNull,
	}
}

func NewEtcdBackupValueUnknown() EtcdBackupValue {
	return EtcdBackupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEtcdBackupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EtcdBackupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EtcdBackupValue Attribute Value",
				"While creating a EtcdBackupValue value, a missing attribute value was detected. "+
					"A EtcdBackupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EtcdBackupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EtcdBackupValue Attribute Type",
				"While creating a EtcdBackupValue value, an invalid attribute value was detected. "+
					"A EtcdBackupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EtcdBackupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EtcdBackupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EtcdBackupValue Attribute Value",
				"While creating a EtcdBackupValue value, an extra attribute value was detected. "+
					"A EtcdBackupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EtcdBackupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEtcdBackupValueUnknown(), diags
	}

	dailyBackupTimeAttribute, ok := attributes["daily_backup_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backup_time is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	dailyBackupTimeVal, ok := dailyBackupTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backup_time expected to be basetypes.StringValue, was: %T`, dailyBackupTimeAttribute))
	}

	intervalInHoursAttribute, ok := attributes["interval_in_hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval_in_hours is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	intervalInHoursVal, ok := intervalInHoursAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval_in_hours expected to be basetypes.Int64Value, was: %T`, intervalInHoursAttribute))
	}

	intervalInMinsAttribute, ok := attributes["interval_in_mins"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval_in_mins is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	intervalInMinsVal, ok := intervalInMinsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval_in_mins expected to be basetypes.Int64Value, was: %T`, intervalInMinsAttribute))
	}

	isEtcdBackupEnabledAttribute, ok := attributes["is_etcd_backup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_etcd_backup_enabled is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	isEtcdBackupEnabledVal, ok := isEtcdBackupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_etcd_backup_enabled expected to be basetypes.BoolValue, was: %T`, isEtcdBackupEnabledAttribute))
	}

	maxIntervalBackupCountAttribute, ok := attributes["max_interval_backup_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_interval_backup_count is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	maxIntervalBackupCountVal, ok := maxIntervalBackupCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_interval_backup_count expected to be basetypes.Int64Value, was: %T`, maxIntervalBackupCountAttribute))
	}

	maxTimestampBackupCountAttribute, ok := attributes["max_timestamp_backup_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_timestamp_backup_count is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	maxTimestampBackupCountVal, ok := maxTimestampBackupCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_timestamp_backup_count expected to be basetypes.Int64Value, was: %T`, maxTimestampBackupCountAttribute))
	}

	storagePropertiesAttribute, ok := attributes["storage_properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_properties is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	storagePropertiesVal, ok := storagePropertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_properties expected to be basetypes.ObjectValue, was: %T`, storagePropertiesAttribute))
	}

	storageTypeAttribute, ok := attributes["storage_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_type is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	storageTypeVal, ok := storageTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_type expected to be basetypes.StringValue, was: %T`, storageTypeAttribute))
	}

	taskErrorDetailAttribute, ok := attributes["task_error_detail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_error_detail is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	taskErrorDetailVal, ok := taskErrorDetailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_error_detail expected to be basetypes.StringValue, was: %T`, taskErrorDetailAttribute))
	}

	taskStatusAttribute, ok := attributes["task_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`task_status is missing from object`)

		return NewEtcdBackupValueUnknown(), diags
	}

	taskStatusVal, ok := taskStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`task_status expected to be basetypes.StringValue, was: %T`, taskStatusAttribute))
	}

	if diags.HasError() {
		return NewEtcdBackupValueUnknown(), diags
	}

	return EtcdBackupValue{
		DailyBackupTime:         dailyBackupTimeVal,
		IntervalInHours:         intervalInHoursVal,
		IntervalInMins:          intervalInMinsVal,
		IsEtcdBackupEnabled:     isEtcdBackupEnabledVal,
		MaxIntervalBackupCount:  maxIntervalBackupCountVal,
		MaxTimestampBackupCount: maxTimestampBackupCountVal,
		StorageProperties:       storagePropertiesVal,
		StorageType:             storageTypeVal,
		TaskErrorDetail:         taskErrorDetailVal,
		TaskStatus:              taskStatusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewEtcdBackupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EtcdBackupValue {
	object, diags := NewEtcdBackupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEtcdBackupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EtcdBackupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEtcdBackupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEtcdBackupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEtcdBackupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEtcdBackupValueMust(EtcdBackupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EtcdBackupType) ValueType(ctx context.Context) attr.Value {
	return EtcdBackupValue{}
}

var _ basetypes.ObjectValuable = EtcdBackupValue{}

type EtcdBackupValue struct {
	DailyBackupTime         basetypes.StringValue `tfsdk:"daily_backup_time"`
	IntervalInHours         basetypes.Int64Value  `tfsdk:"interval_in_hours"`
	IntervalInMins          basetypes.Int64Value  `tfsdk:"interval_in_mins"`
	IsEtcdBackupEnabled     basetypes.BoolValue   `tfsdk:"is_etcd_backup_enabled"`
	MaxIntervalBackupCount  basetypes.Int64Value  `tfsdk:"max_interval_backup_count"`
	MaxTimestampBackupCount basetypes.Int64Value  `tfsdk:"max_timestamp_backup_count"`
	StorageProperties       basetypes.ObjectValue `tfsdk:"storage_properties"`
	StorageType             basetypes.StringValue `tfsdk:"storage_type"`
	TaskErrorDetail         basetypes.StringValue `tfsdk:"task_error_detail"`
	TaskStatus              basetypes.StringValue `tfsdk:"task_status"`
	state                   attr.ValueState
}

func (v EtcdBackupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["daily_backup_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval_in_hours"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interval_in_mins"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_etcd_backup_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_interval_backup_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_timestamp_backup_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage_properties"] = basetypes.ObjectType{
		AttrTypes: StoragePropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["storage_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["task_error_detail"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["task_status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.DailyBackupTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_backup_time"] = val

		val, err = v.IntervalInHours.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval_in_hours"] = val

		val, err = v.IntervalInMins.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval_in_mins"] = val

		val, err = v.IsEtcdBackupEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_etcd_backup_enabled"] = val

		val, err = v.MaxIntervalBackupCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_interval_backup_count"] = val

		val, err = v.MaxTimestampBackupCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_timestamp_backup_count"] = val

		val, err = v.StorageProperties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_properties"] = val

		val, err = v.StorageType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_type"] = val

		val, err = v.TaskErrorDetail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["task_error_detail"] = val

		val, err = v.TaskStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["task_status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EtcdBackupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EtcdBackupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EtcdBackupValue) String() string {
	return "EtcdBackupValue"
}

func (v EtcdBackupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var storageProperties basetypes.ObjectValue

	if v.StorageProperties.IsNull() {
		storageProperties = types.ObjectNull(
			StoragePropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.StorageProperties.IsUnknown() {
		storageProperties = types.ObjectUnknown(
			StoragePropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StorageProperties.IsNull() && !v.StorageProperties.IsUnknown() {
		storageProperties = types.ObjectValueMust(
			StoragePropertiesValue{}.AttributeTypes(ctx),
			v.StorageProperties.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"daily_backup_time":          basetypes.StringType{},
			"interval_in_hours":          basetypes.Int64Type{},
			"interval_in_mins":           basetypes.Int64Type{},
			"is_etcd_backup_enabled":     basetypes.BoolType{},
			"max_interval_backup_count":  basetypes.Int64Type{},
			"max_timestamp_backup_count": basetypes.Int64Type{},
			"storage_properties": basetypes.ObjectType{
				AttrTypes: StoragePropertiesValue{}.AttributeTypes(ctx),
			},
			"storage_type":      basetypes.StringType{},
			"task_error_detail": basetypes.StringType{},
			"task_status":       basetypes.StringType{},
		},
		map[string]attr.Value{
			"daily_backup_time":          v.DailyBackupTime,
			"interval_in_hours":          v.IntervalInHours,
			"interval_in_mins":           v.IntervalInMins,
			"is_etcd_backup_enabled":     v.IsEtcdBackupEnabled,
			"max_interval_backup_count":  v.MaxIntervalBackupCount,
			"max_timestamp_backup_count": v.MaxTimestampBackupCount,
			"storage_properties":         storageProperties,
			"storage_type":               v.StorageType,
			"task_error_detail":          v.TaskErrorDetail,
			"task_status":                v.TaskStatus,
		})

	return objVal, diags
}

func (v EtcdBackupValue) Equal(o attr.Value) bool {
	other, ok := o.(EtcdBackupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DailyBackupTime.Equal(other.DailyBackupTime) {
		return false
	}

	if !v.IntervalInHours.Equal(other.IntervalInHours) {
		return false
	}

	if !v.IntervalInMins.Equal(other.IntervalInMins) {
		return false
	}

	if !v.IsEtcdBackupEnabled.Equal(other.IsEtcdBackupEnabled) {
		return false
	}

	if !v.MaxIntervalBackupCount.Equal(other.MaxIntervalBackupCount) {
		return false
	}

	if !v.MaxTimestampBackupCount.Equal(other.MaxTimestampBackupCount) {
		return false
	}

	if !v.StorageProperties.Equal(other.StorageProperties) {
		return false
	}

	if !v.StorageType.Equal(other.StorageType) {
		return false
	}

	if !v.TaskErrorDetail.Equal(other.TaskErrorDetail) {
		return false
	}

	if !v.TaskStatus.Equal(other.TaskStatus) {
		return false
	}

	return true
}

func (v EtcdBackupValue) Type(ctx context.Context) attr.Type {
	return EtcdBackupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EtcdBackupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daily_backup_time":          basetypes.StringType{},
		"interval_in_hours":          basetypes.Int64Type{},
		"interval_in_mins":           basetypes.Int64Type{},
		"is_etcd_backup_enabled":     basetypes.BoolType{},
		"max_interval_backup_count":  basetypes.Int64Type{},
		"max_timestamp_backup_count": basetypes.Int64Type{},
		"storage_properties": basetypes.ObjectType{
			AttrTypes: StoragePropertiesValue{}.AttributeTypes(ctx),
		},
		"storage_type":      basetypes.StringType{},
		"task_error_detail": basetypes.StringType{},
		"task_status":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StoragePropertiesType{}

type StoragePropertiesType struct {
	basetypes.ObjectType
}

func (t StoragePropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(StoragePropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StoragePropertiesType) String() string {
	return "StoragePropertiesType"
}

func (t StoragePropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localPathAttribute, ok := attributes["local_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_path is missing from object`)

		return nil, diags
	}

	localPathVal, ok := localPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_path expected to be basetypes.StringValue, was: %T`, localPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StoragePropertiesValue{
		LocalPath: localPathVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStoragePropertiesValueNull() StoragePropertiesValue {
	return StoragePropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewStoragePropertiesValueUnknown() StoragePropertiesValue {
	return StoragePropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStoragePropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StoragePropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StoragePropertiesValue Attribute Value",
				"While creating a StoragePropertiesValue value, a missing attribute value was detected. "+
					"A StoragePropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StoragePropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StoragePropertiesValue Attribute Type",
				"While creating a StoragePropertiesValue value, an invalid attribute value was detected. "+
					"A StoragePropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StoragePropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StoragePropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StoragePropertiesValue Attribute Value",
				"While creating a StoragePropertiesValue value, an extra attribute value was detected. "+
					"A StoragePropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StoragePropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStoragePropertiesValueUnknown(), diags
	}

	localPathAttribute, ok := attributes["local_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_path is missing from object`)

		return NewStoragePropertiesValueUnknown(), diags
	}

	localPathVal, ok := localPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_path expected to be basetypes.StringValue, was: %T`, localPathAttribute))
	}

	if diags.HasError() {
		return NewStoragePropertiesValueUnknown(), diags
	}

	return StoragePropertiesValue{
		LocalPath: localPathVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStoragePropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StoragePropertiesValue {
	object, diags := NewStoragePropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStoragePropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StoragePropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStoragePropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStoragePropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStoragePropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStoragePropertiesValueMust(StoragePropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StoragePropertiesType) ValueType(ctx context.Context) attr.Value {
	return StoragePropertiesValue{}
}

var _ basetypes.ObjectValuable = StoragePropertiesValue{}

type StoragePropertiesValue struct {
	LocalPath basetypes.StringValue `tfsdk:"local_path"`
	state     attr.ValueState
}

func (v StoragePropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["local_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.LocalPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StoragePropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StoragePropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StoragePropertiesValue) String() string {
	return "StoragePropertiesValue"
}

func (v StoragePropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"local_path": basetypes.StringType{},
		},
		map[string]attr.Value{
			"local_path": v.LocalPath,
		})

	return objVal, diags
}

func (v StoragePropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(StoragePropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LocalPath.Equal(other.LocalPath) {
		return false
	}

	return true
}

func (v StoragePropertiesValue) Type(ctx context.Context) attr.Type {
	return StoragePropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StoragePropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local_path": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	state attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{},
		map[string]attr.Value{})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
